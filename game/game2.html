<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isometric Reconnaissance</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0e27; font-family: 'Courier New', monospace; color: #00ff41; }
        canvas { display: block; width: 100%; height: 100%; }
        .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15) 0%, rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px); }
        #hud { position: fixed; top: 20px; left: 20px; z-index: 40; font-size: 14px; line-height: 1.6; text-shadow: 0 0 10px rgba(0,255,65,0.5); }
        .hud-line { color: #00ff41; margin: 4px 0; text-transform: uppercase; }
        .hud-label { color: #ff10f0; }
        .hud-value { color: #00ffff; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; z-index: 100; }
        .modal-backdrop.active { display: flex; align-items: center; justify-content: center; }
        .challenge-modal { background: rgba(10,14,39,0.95); border: 3px solid #00ff41; padding: 40px; max-width: 600px; width: 90%; box-shadow: 0 0 30px rgba(0,255,65,0.3); }
        .challenge-modal h2 { color: #00ff41; font-size: 24px; margin-bottom: 20px; text-transform: uppercase; text-shadow: -3px 0 0 #ff10f0, 3px 0 0 #00ffff; }
        .challenge-modal p { color: #00ffff; font-size: 16px; margin-bottom: 30px; }
        .timer-bar { width: 100%; height: 12px; background: #0a0e27; border: 2px solid #00ff41; margin-bottom: 30px; overflow: hidden; }
        .timer-fill { height: 100%; background: linear-gradient(90deg, #00ff41, #39ff14); width: 100%; }
        .option-label { display: flex; padding: 10px; margin: 8px 0; background: rgba(0,255,65,0.05); border: 2px solid #00ff41; cursor: pointer; }
        .option-label:hover { background: rgba(0,255,65,0.15); }
        .option-label input { margin-right: 10px; accent-color: #00ff41; cursor: pointer; }
        .option-text { color: #00ffff; }
        button { padding: 10px 20px; background: #0a0e27; color: #00ff41; border: 2px solid #00ff41; font-family: monospace; cursor: pointer; margin-right: 10px; text-transform: uppercase; }
        button:hover { background: #00ff41; color: #0a0e27; }
        .toast { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); background: rgba(0,255,65,0.95); color: #0a0e27; padding: 16px 32px; z-index: 101; font-weight: bold; }
        .toast.failure { background: rgba(255,0,0,0.95); color: #fff; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div id="hud">
        <div class="hud-line"><span class="hud-label">SCORE:</span> <span class="hud-value" id="scoreDisplay">0</span></div>
        <div class="hud-line"><span class="hud-label">DIFFICULTY:</span> <span class="hud-value" id="difficultyDisplay">1.0x</span></div>
        <div class="hud-line"><span class="hud-label">NPCS:</span> <span class="hud-value" id="npcDisplay">0/6</span></div>
        <div class="hud-line"><span class="hud-label">ACCURACY:</span> <span class="hud-value" id="accuracyDisplay">0%</span></div>
    </div>

    <div id="modalBackdrop" class="modal-backdrop">
        <div class="challenge-modal">
            <h2 id="challengeTitle"></h2>
            <p id="challengeText"></p>
            <div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>
            <div id="optionsGroup"></div>
            <button id="submitBtn">SUBMIT</button>
            <button id="cancelBtn">CANCEL</button>
        </div>
    </div>

    <script>
        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game Constants
        const TILE_SIZE = 40;
        const MAP_WIDTH = 20;
        const MAP_HEIGHT = 16;
        const PLAYER_SPEED = 150; // pixels per second
        const ISO_X_OFFSET = 0.5;
        const ISO_Y_OFFSET = 0.25;

        // Colors
        const COLORS = {
            bg: '#0a0e27',
            green: '#00ff41',
            cyan: '#00ffff',
            magenta: '#ff10f0',
            lime: '#39ff14',
            water: '#0088ff',
            stone: '#666666'
        };

        // Game State
        const gameState = {
            playerPos: { x: 10, y: 8 },
            pathQueue: [],
            score: 0,
            difficulty: 1.0,
            npcsMet: 0,
            totalAttempts: 0,
            correctAnswers: 0,
            challengeActive: false,
            selectedOption: null
        };

        let tilemap = new Uint8Array(MAP_WIDTH * MAP_HEIGHT);
        let npcMap = {};
        let lastTime = Date.now();

        // NPCs
        const npcs = [
            { pos: {x:2, y:2}, title: 'PACKET ANALYSIS', question: 'Port 443 protocol?', options: ['HTTPS', 'FTP', 'Telnet', 'SMTP'], correct: 0 },
            { pos: {x:17, y:3}, title: 'DECODE SIGNAL', question: '"48656C6C6F" hex?', options: ['Hello', 'Help', 'Hallo', 'Helix'], correct: 0 },
            { pos: {x:10, y:14}, title: 'ERROR FORENSICS', question: 'HTTP 401 means?', options: ['Unauthorized', 'Not Found', 'Error', 'Bad Gateway'], correct: 0 },
            { pos: {x:3, y:12}, title: 'SECURITY AUDIT', question: 'Plaintext auth?', options: ['Basic Auth', 'OAuth', 'JWT', 'Kerberos'], correct: 0 },
            { pos: {x:16, y:10}, title: 'GATEWAY ANALYSIS', question: 'SYN flood targets?', options: ['Transport', 'Application', 'Data Link', 'Physical'], correct: 0 },
            { pos: {x:8, y:2}, title: 'CIPHER MASTERY', question: 'Salt purpose?', options: ['Rainbow table', 'Speed up', 'Encrypt', 'Verify'], correct: 0 }
        ];

        // Initialize tilemap
        function initTilemap() {
            for (let i = 0; i < tilemap.length; i++) tilemap[i] = 0;
            for (let i = 0; i < 25; i++) {
                const x = Math.floor(Math.random() * MAP_WIDTH);
                const y = Math.floor(Math.random() * MAP_HEIGHT);
                if (Math.abs(x - 10) > 2 || Math.abs(y - 8) > 2) {
                    tilemap[y * MAP_WIDTH + x] = Math.random() > 0.5 ? 1 : 2;
                }
            }
            npcs.forEach(npc => {
                npcMap[npc.pos.x + ',' + npc.pos.y] = npc;
            });
        }

        function isWalkable(x, y) {
            return x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT && tilemap[y * MAP_WIDTH + x] === 0;
        }

        // Isometric projection
        function gridToIso(gridX, gridY) {
            const isoX = (gridX - gridY) * TILE_SIZE * ISO_X_OFFSET;
            const isoY = (gridX + gridY) * TILE_SIZE * ISO_Y_OFFSET;
            return { x: isoX, y: isoY };
        }

        function isoToGrid(isoX, isoY) {
            const gridX = (isoX / (TILE_SIZE * ISO_X_OFFSET) + isoY / (TILE_SIZE * ISO_Y_OFFSET)) / 2;
            const gridY = (isoY / (TILE_SIZE * ISO_Y_OFFSET) - isoX / (TILE_SIZE * ISO_X_OFFSET)) / 2;
            return { x: Math.round(gridX), y: Math.round(gridY) };
        }

        // Pathfinding
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function findPath(start, goal) {
            const openSet = [start];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            const key = p => p.x + ',' + p.y;

            gScore.set(key(start), 0);
            fScore.set(key(start), heuristic(start, goal));

            while (openSet.length > 0) {
                let current = openSet[0];
                let currentIdx = 0;
                for (let i = 1; i < openSet.length; i++) {
                    if (fScore.get(key(openSet[i])) < fScore.get(key(current))) {
                        current = openSet[i];
                        currentIdx = i;
                    }
                }

                if (current.x === goal.x && current.y === goal.y) {
                    const path = [current];
                    let curr = current;
                    while (cameFrom.has(key(curr))) {
                        curr = cameFrom.get(key(curr));
                        path.unshift(curr);
                    }
                    return path;
                }

                openSet.splice(currentIdx, 1);

                const neighbors = [
                    {x: current.x+1, y: current.y},
                    {x: current.x-1, y: current.y},
                    {x: current.x, y: current.y+1},
                    {x: current.x, y: current.y-1}
                ];

                for (const neighbor of neighbors) {
                    if (!isWalkable(neighbor.x, neighbor.y)) continue;
                    const tentativeGScore = gScore.get(key(current)) + 1;
                    if (!gScore.has(key(neighbor)) || tentativeGScore < gScore.get(key(neighbor))) {
                        cameFrom.set(key(neighbor), current);
                        gScore.set(key(neighbor), tentativeGScore);
                        fScore.set(key(neighbor), tentativeGScore + heuristic(neighbor, goal));
                        if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return [];
        }

        // Rendering
        function drawTile(gridX, gridY, tileType) {
            const iso = gridToIso(gridX, gridY);
            const screenX = canvas.width / 2 + iso.x;
            const screenY = canvas.height / 2 + iso.y;

            const points = [
                { x: TILE_SIZE * ISO_X_OFFSET, y: 0 },
                { x: TILE_SIZE * ISO_X_OFFSET * 2, y: TILE_SIZE * ISO_Y_OFFSET },
                { x: TILE_SIZE * ISO_X_OFFSET, y: TILE_SIZE * ISO_Y_OFFSET * 2 },
                { x: 0, y: TILE_SIZE * ISO_Y_OFFSET }
            ];

            let color = COLORS.green;
            if (tileType === 1) color = COLORS.water;
            if (tileType === 2) color = COLORS.stone;

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(screenX + points[0].x, screenY + points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(screenX + points[i].x, screenY + points[i].y);
            }
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = COLORS.green;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawPlayer() {
            const iso = gridToIso(gameState.playerPos.x, gameState.playerPos.y);
            const screenX = canvas.width / 2 + iso.x + TILE_SIZE * ISO_X_OFFSET;
            const screenY = canvas.height / 2 + iso.y + TILE_SIZE * ISO_Y_OFFSET;

            // Body
            ctx.fillStyle = COLORS.lime;
            ctx.fillRect(screenX - 8, screenY - 12, 16, 24);

            // Head
            ctx.fillStyle = COLORS.green;
            ctx.beginPath();
            ctx.arc(screenX, screenY - 16, 8, 0, Math.PI * 2);
            ctx.fill();

            // Glow
            ctx.strokeStyle = COLORS.cyan;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(screenX, screenY - 16, 12, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawNPCs() {
            npcs.forEach(npc => {
                const iso = gridToIso(npc.pos.x, npc.pos.y);
                const screenX = canvas.width / 2 + iso.x + TILE_SIZE * ISO_X_OFFSET;
                const screenY = canvas.height / 2 + iso.y + TILE_SIZE * ISO_Y_OFFSET;

                // Body
                ctx.fillStyle = COLORS.cyan;
                ctx.fillRect(screenX - 6, screenY - 12, 12, 20);

                // Head
                ctx.fillStyle = COLORS.magenta;
                ctx.beginPath();
                ctx.arc(screenX, screenY - 16, 6, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = COLORS.magenta;
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX - 8, screenY - 14, 16, 22);
            });
        }

        function render() {
            // Clear
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw tiles
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const tileType = tilemap[y * MAP_WIDTH + x];
                    drawTile(x, y, tileType);
                }
            }

            // Draw NPCs
            drawNPCs();

            // Draw player
            drawPlayer();

            requestAnimationFrame(render);
        }

        // Click/Touch Input
        function screenToGrid(screenX, screenY) {
            const relX = screenX - canvas.width / 2;
            const relY = screenY - canvas.height / 2;
            return isoToGrid(relX, relY);
        }

        function onCanvasClick(event) {
            if (gameState.challengeActive) return;

            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;

            const grid = screenToGrid(screenX, screenY);
            grid.x = Math.max(0, Math.min(MAP_WIDTH - 1, grid.x));
            grid.y = Math.max(0, Math.min(MAP_HEIGHT - 1, grid.y));

            const npcKey = grid.x + ',' + grid.y;
            if (npcMap.hasOwnProperty(npcKey)) {
                showChallenge(npcMap[npcKey]);
                return;
            }

            if (isWalkable(grid.x, grid.y)) {
                const path = findPath(gameState.playerPos, {x: grid.x, y: grid.y});
                gameState.pathQueue = path.slice(1);
            }
        }

        canvas.addEventListener('click', onCanvasClick);
        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const clickEvent = new MouseEvent('click', { clientX: touch.clientX, clientY: touch.clientY });
            canvas.dispatchEvent(clickEvent);
        });

        // Challenge System
        const challengePool = [
            { title: 'AUTHENTICATE', question: 'MFA does NOT include?', options: ['Know', 'Remember', 'Have', 'Are'], correct: 1 },
            { title: 'NETWORK SCAN', question: 'NMAP = ?', options: ['Network Mapper', 'Monitor', 'Map', 'Manager'], correct: 0 },
            { title: 'VULNERABILITY', question: 'XSS exploits?', options: ['Client validation', 'Firewall', 'Latency', 'Crypto'], correct: 0 },
            { title: 'FORENSICS', question: 'Honeypot purpose?', options: ['Attract', 'Encrypt', 'Speed', 'Validate'], correct: 0 },
            { title: 'CIPHER TEXT', question: 'DES is?', options: ['Deprecated', 'Modern', 'Standard', 'Advanced'], correct: 0 },
            { title: 'INTRUSION', question: 'IDS vs IPS?', options: ['Detect only', 'Block only', 'Manual', 'Offline'], correct: 0 },
            { title: 'MALWARE', question: 'Self-replicating?', options: ['Virus', 'Trojan', 'Rootkit', 'Ransomware'], correct: 0 },
            { title: 'DATA BREACH', question: 'Main cause?', options: ['Phishing', 'Disaster', 'Hardware', 'Radiation'], correct: 0 }
        ];

        function showChallenge(npc) {
            const challenge = challengePool[Math.floor(Math.random() * challengePool.length)];

            gameState.currentChallenge = { ...challenge, npc };
            gameState.selectedOption = null;
            gameState.challengeActive = true;

            document.getElementById('challengeTitle').textContent = challenge.title;
            document.getElementById('challengeText').textContent = challenge.question;

            const optionsGroup = document.getElementById('optionsGroup');
            optionsGroup.innerHTML = '';
            challenge.options.forEach((opt, idx) => {
                const label = document.createElement('label');
                label.className = 'option-label';
                label.innerHTML = `<input type="radio" name="option" value="${idx}"><span class="option-text">${String.fromCharCode(65+idx)}) ${opt}</span>`;
                label.addEventListener('change', () => { gameState.selectedOption = idx; });
                optionsGroup.appendChild(label);
            });

            document.getElementById('modalBackdrop').classList.add('active');
            gameState.challengeTime = 60;
            gameState.challengeStart = Date.now();
        }

        function submitChallenge() {
            if (gameState.selectedOption === null) return;

            const isCorrect = gameState.selectedOption === gameState.currentChallenge.correct;
            gameState.totalAttempts++;

            if (isCorrect) {
                gameState.correctAnswers++;
                gameState.npcsMet++;
                const points = Math.floor(10 * gameState.difficulty);
                gameState.score += points;
                gameState.difficulty += 0.2;
                showToast(`+${points} POINTS`, 'success');
            } else {
                gameState.score = Math.max(0, gameState.score - 5);
                showToast('INCORRECT -5', 'failure');
            }

            updateHUD();
            closeChallenge();
        }

        function closeChallenge() {
            gameState.challengeActive = false;
            document.getElementById('modalBackdrop').classList.remove('active');
        }

        function showToast(msg, type) {
            const toast = document.createElement('div');
            toast.className = 'toast ' + (type === 'failure' ? 'failure' : '');
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('difficultyDisplay').textContent = gameState.difficulty.toFixed(1) + 'x';
            document.getElementById('npcDisplay').textContent = gameState.npcsMet + '/6';
            const acc = gameState.totalAttempts > 0 ? Math.round(gameState.correctAnswers / gameState.totalAttempts * 100) : 0;
            document.getElementById('accuracyDisplay').textContent = acc + '%';
        }

        document.getElementById('submitBtn').addEventListener('click', submitChallenge);
        document.getElementById('cancelBtn').addEventListener('click', closeChallenge);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Player Movement
        function updatePlayer(dt) {
            if (gameState.pathQueue.length === 0) return;

            const next = gameState.pathQueue[0];
            const dx = next.x - gameState.playerPos.x;
            const dy = next.y - gameState.playerPos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const moveAmount = PLAYER_SPEED * dt;

            if (dist <= moveAmount / 100) {
                gameState.playerPos = next;
                gameState.pathQueue.shift();
            } else {
                gameState.playerPos.x += (dx / dist) * moveAmount / 100;
                gameState.playerPos.y += (dy / dist) * moveAmount / 100;
            }
        }

        // Game Loop
        function gameLoop() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            updatePlayer(dt);

            if (gameState.challengeActive) {
                const elapsed = (Date.now() - gameState.challengeStart) / 1000;
                gameState.challengeTime = Math.max(0, 60 - elapsed);
                const progress = gameState.challengeTime / 60;
                document.getElementById('timerFill').style.width = (progress * 100) + '%';

                if (gameState.challengeTime <= 0) {
                    closeChallenge();
                }
            }

            updateHUD();
        }

        // Init
        initTilemap();
        render();
        setInterval(gameLoop, 1000 / 60);
    </script>
</body>
</html>
