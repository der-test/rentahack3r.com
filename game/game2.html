<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DATASCAPE EXPLORATION</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0e27; font-family: 'Courier New', monospace; color: #00ff41; }
        canvas { display: block; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0e27 0%, #1a1e47 100%); }
        .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15) 0%, rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px); animation: scan 0.08s linear infinite; }
        @keyframes scan { 0% { transform: translateY(0); } 100% { transform: translateY(4px); } }
        #hud { position: fixed; top: 20px; left: 20px; z-index: 40; font-size: 13px; line-height: 1.5; text-shadow: 0 0 10px rgba(0,255,65,0.5); background: rgba(10,14,39,0.8); border: 2px solid #00ff41; padding: 12px; }
        .hud-line { color: #00ff41; margin: 3px 0; text-transform: uppercase; }
        .hud-label { color: #ff10f0; }
        .hud-value { color: #00ffff; }
        .crosshair { position: fixed; top: 50%; left: 50%; z-index: 30; transform: translate(-50%, -50%); width: 20px; height: 20px; border: 2px solid #00ff41; }
        .crosshair::before, .crosshair::after { content: ''; position: absolute; background: #00ff41; }
        .crosshair::before { width: 2px; height: 10px; left: 9px; top: -15px; }
        .crosshair::after { width: 10px; height: 2px; left: -15px; top: 9px; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; z-index: 100; }
        .modal-backdrop.active { display: flex; align-items: center; justify-content: center; }
        .challenge-modal { background: rgba(10,14,39,0.98); border: 3px solid #00ff41; padding: 30px; max-width: 550px; width: 90%; box-shadow: 0 0 40px rgba(0,255,65,0.4); }
        .challenge-modal h2 { color: #00ff41; font-size: 20px; margin-bottom: 15px; text-transform: uppercase; text-shadow: -2px 0 0 #ff10f0, 2px 0 0 #00ffff; }
        .challenge-modal p { color: #00ffff; font-size: 14px; margin-bottom: 20px; }
        .timer-bar { width: 100%; height: 10px; background: #0a0e27; border: 2px solid #00ff41; margin-bottom: 20px; overflow: hidden; }
        .timer-fill { height: 100%; background: linear-gradient(90deg, #00ff41, #39ff14); width: 100%; transition: width 0.1s; }
        .option-label { display: flex; padding: 8px; margin: 6px 0; background: rgba(0,255,65,0.05); border: 2px solid #00ff41; cursor: pointer; }
        .option-label:hover { background: rgba(0,255,65,0.15); }
        .option-label input { margin-right: 8px; accent-color: #00ff41; cursor: pointer; }
        .option-text { color: #00ffff; font-size: 13px; }
        button { padding: 8px 16px; background: #0a0e27; color: #00ff41; border: 2px solid #00ff41; font-family: monospace; cursor: pointer; margin-right: 8px; text-transform: uppercase; font-size: 12px; }
        button:hover { background: #00ff41; color: #0a0e27; }
        .toast { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); background: rgba(0,255,65,0.95); color: #0a0e27; padding: 12px 24px; z-index: 101; font-weight: bold; font-size: 12px; }
        .toast.failure { background: rgba(255,0,0,0.95); color: #fff; }
        #minimap { position: fixed; bottom: 20px; right: 20px; width: 150px; height: 150px; border: 2px solid #00ff41; background: rgba(10,14,39,0.9); z-index: 40; }
        .controls { position: fixed; bottom: 20px; left: 20px; z-index: 40; font-size: 11px; background: rgba(10,14,39,0.8); border: 2px solid #00ff41; padding: 8px; color: #00ffff; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="crosshair"></div>

    <div id="hud">
        <div class="hud-line"><span class="hud-label">POS:</span> <span class="hud-value" id="posDisplay">0.0, 0.0, 0.0</span></div>
        <div class="hud-line"><span class="hud-label">SCORE:</span> <span class="hud-value" id="scoreDisplay">0</span></div>
        <div class="hud-line"><span class="hud-label">SYSTEMS:</span> <span class="hud-value" id="systemsDisplay">0/8</span></div>
        <div class="hud-line"><span class="hud-label">SPEED:</span> <span class="hud-value" id="speedDisplay">0.0</span></div>
        <div style="margin-top: 8px; border-top: 1px solid #00ff41;"></div>
        <div class="hud-line" style="margin-top: 8px;"><span class="hud-label">QUEST:</span></div>
        <div id="questDisplay" style="font-size: 11px; color: #00ff41; line-height: 1.3; margin-left: 8px;">
            <div id="buildingStatus">SCANNING...</div>
        </div>
    </div>

    <div class="controls">
        <div style="color: #ff10f0;">MOVEMENT:</div>
        <div>CLICK/TAP - MOVE</div>
        <div style="color: #ff10f0; margin-top: 4px;">DRAG - LOOK</div>
    </div>

    <canvas id="minimap"></canvas>

    <div id="modalBackdrop" class="modal-backdrop">
        <div class="challenge-modal">
            <h2 id="challengeTitle"></h2>
            <p id="challengeText"></p>
            <div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>
            <div id="optionsGroup"></div>
            <button id="submitBtn">SUBMIT</button>
            <button id="cancelBtn">SKIP</button>
        </div>
    </div>

    <script>
        // ============== MATH & UTILITY ==============
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x; this.y = y; this.z = z;
            }
            clone() { return new Vec3(this.x, this.y, this.z); }
            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            dist(v) {
                const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
                return Math.sqrt(dx*dx + dy*dy + dz*dz);
            }
            normalize() {
                const len = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
                return len > 0 ? new Vec3(this.x/len, this.y/len, this.z/len) : new Vec3();
            }
            dot(v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
        }

        // ============== CANVAS SETUP ==============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ============== CAMERA & INPUT ==============
        const camera = {
            pos: new Vec3(50, 5, 50),
            euler: { x: 0, y: 0 },
            fov: 60,
            getForward() {
                return new Vec3(
                    Math.sin(this.euler.y),
                    0,
                    Math.cos(this.euler.y)
                );
            },
            getRight() {
                return new Vec3(
                    Math.cos(this.euler.y),
                    0,
                    -Math.sin(this.euler.y)
                );
            }
        };

        const mouse = { dx: 0, dy: 0, dragging: false, lastX: 0, lastY: 0, dragDistance: 0, startX: 0, startY: 0 };
        const movement = { targetPos: null, isMoving: false };

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            
            mouse.dragging = true;
            mouse.dragDistance = 0;
            mouse.lastX = screenX;
            mouse.lastY = screenY;
            mouse.startX = screenX;
            mouse.startY = screenY;
        });

        canvas.addEventListener('mouseup', (e) => {
            if (mouse.dragDistance < 10 && !gameState.challengeActive) {
                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                setMoveTarget(screenX, screenY);
            }
            mouse.dragging = false;
            mouse.dragDistance = 0;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!mouse.dragging) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            
            const dx = screenX - mouse.lastX;
            const dy = screenY - mouse.lastY;
            mouse.dragDistance += Math.sqrt(dx*dx + dy*dy);
            
            mouse.dx += dx * 0.002;
            mouse.dy += dy * 0.002;
            
            mouse.lastX = screenX;
            mouse.lastY = screenY;
        });

        canvas.addEventListener('touchstart', (e) => {
            if (gameState.challengeActive) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const screenX = touch.clientX - rect.left;
            const screenY = touch.clientY - rect.top;
            setMoveTarget(screenX, screenY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, false);

        // ============== WORLD GENERATION ==============
        const worldNoise = {
            seed: 12345,
            hash(x, y) {
                let h = this.seed + x * 374761393 ^ y * 668265263;
                h = (h ^ (h >> 13)) * 274761393;
                return ((h ^ (h >> 16)) & 2147483647) / 2147483647;
            },
            perlin2d(x, y) {
                const xi = Math.floor(x), yi = Math.floor(y);
                const xf = x - xi, yf = y - yi;
                const u = xf * xf * (3 - 2*xf), v = yf * yf * (3 - 2*yf);
                
                const n00 = this.hash(xi, yi);
                const n10 = this.hash(xi+1, yi);
                const n01 = this.hash(xi, yi+1);
                const n11 = this.hash(xi+1, yi+1);
                
                const nx0 = n00 + u * (n10 - n00);
                const nx1 = n01 + u * (n11 - n01);
                return nx0 + v * (nx1 - nx0);
            },
            getHeight(x, z) {
                let height = 0;
                height += this.perlin2d(x*0.05, z*0.05) * 3;
                height += this.perlin2d(x*0.1, z*0.1) * 1.5;
                return height;
            },
            getTerrain(x, z) {
                const height = this.getHeight(x, z);
                if (height < -0.5) return 'water';
                if (height < 0.2) return 'dirt';
                if (height < 1) return 'grass';
                return 'stone';
            }
        };

        // ============== GAME STATE ==============
        const gameState = {
            score: 0,
            systemsMet: 0,
            totalAttempts: 0,
            correctAnswers: 0,
            challengeActive: false,
            selectedOption: null,
            playerSpeed: 0
        };

        // ============== NPCs ==============
        const npcs = [];
        const npcPositions = [
            {x: 30, z: 30, name: 'NODE_A'},
            {x: 70, z: 40, name: 'NODE_B'},
            {x: 50, z: 70, name: 'NODE_C'},
            {x: 20, z: 60, name: 'NODE_D'},
            {x: 80, z: 20, name: 'NODE_E'},
            {x: 60, z: 55, name: 'NODE_F'},
            {x: 35, z: 45, name: 'NODE_G'},
            {x: 75, z: 75, name: 'NODE_H'}
        ];

        // ============== BUILDINGS ==============
        const buildings = [];
        const npcHouses = {}; // Track which NPCs live in which houses
        function generateBuildings() {
            const houseCount = 10;
            const npcIndices = [0, 1, 2, 3]; // First 4 NPCs live in houses
            
            for (let i = 0; i < houseCount; i++) {
                let x = 15 + (i % 3) * 25 + Math.random() * 8;
                let z = 15 + Math.floor(i / 3) * 25 + Math.random() * 8;
                x = Math.max(10, Math.min(90, x));
                z = Math.max(10, Math.min(90, z));
                
                const h = worldNoise.getHeight(x, z);
                const terrain = worldNoise.getTerrain(x, z);
                
                if (terrain !== 'water' && terrain !== 'stone') {
                    const hasNPC = i < 4;
                    const npcIndex = hasNPC ? npcIndices[i] : -1;
                    
                    const house = {
                        pos: new Vec3(x, h, z),
                        width: 6,
                        depth: 7,
                        height: 5,
                        roofHeight: 3,
                        color: ['#ff6666', '#6666ff', '#66ff66', '#ffff66', '#ff66ff', '#66ffff'][Math.floor(Math.random() * 6)],
                        hasNPC: hasNPC,
                        npcIndex: npcIndex,
                        distToPlayer: 999,
                        type: 'house',
                        challengeCompleted: false
                    };
                    
                    buildings.push(house);
                    
                    if (hasNPC) {
                        npcHouses[npcIndex] = house;
                    }
                }
            }
        }
        generateBuildings();

        // Initialize NPCs - they'll be positioned at their house locations if they have one
        npcPositions.forEach((pos, idx) => {
            const classTypes = ['hacker', 'agent', 'cyborg', 'ghost'];
            const charClass = classTypes[Math.floor(Math.random() * classTypes.length)];
            const primaryColor = ['#ff10f0', '#00ffff', '#39ff14', '#ffff00'][Math.floor(Math.random() * 4)];
            const accentColor = ['#ff4488', '#00ff88', '#88ff00', '#ffff00'][Math.floor(Math.random() * 4)];
            
            // Check if this NPC lives in a house
            let npcPos;
            let atHome = false;
            if (npcHouses[idx]) {
                const house = npcHouses[idx];
                // Place NPC at house entrance (slightly outside door)
                npcPos = new Vec3(house.pos.x, house.pos.y + 2, house.pos.z + 3);
                atHome = true;
            } else {
                // Default position in open world
                const h = worldNoise.getHeight(pos.x, pos.z);
                npcPos = new Vec3(pos.x, h + 2, pos.z);
            }
            
            npcs.push({
                pos: npcPos,
                name: pos.name,
                active: false,
                distToPlayer: 999,
                class: charClass,
                primaryColor: primaryColor,
                accentColor: accentColor,
                skinColor: '#ff9999',
                animationOffset: Math.random() * Math.PI * 2,
                atHome: atHome,
                houseIndex: npcHouses[idx] ? buildings.indexOf(npcHouses[idx]) : -1
            });
        });

        // ============== CHALLENGE POOL ==============
        const challenges = [
            { title: 'EXPLOIT DETECTED', question: 'SQL injection targets?', options: ['Database', 'Firewall', 'Memory', 'Cache'], correct: 0 },
            { title: 'BREACH PROTOCOL', question: 'Zero-day definition?', options: ['Unknown exploit', 'Old bug', 'Documented flaw', 'Feature'], correct: 0 },
            { title: 'CRYPTO ANALYSIS', question: 'SHA256 output size?', options: ['256 bits', '256 bytes', '128 bits', '512 bits'], correct: 0 },
            { title: 'NETWORK TRACE', question: 'HTTPS default port?', options: ['443', '80', '8080', '22'], correct: 0 },
            { title: 'MEMORY DUMP', question: 'Buffer overflow risk?', options: ['Unbounded copy', 'Encryption', 'Checksum', 'Sorting'], correct: 0 },
            { title: 'CODE REVIEW', question: 'CSRF protection?', options: ['Token validation', 'Encryption', 'Rate limit', 'Logging'], correct: 0 },
            { title: 'INTRUSION LOG', question: 'Rootkit operates in?', options: ['Kernel space', 'User space', 'Ring 3', 'Application'], correct: 0 },
            { title: 'THREAT SCAN', question: 'Ransomware = ?', options: ['Encrypt + ransom', 'Copy + steal', 'Delete + log', 'Stall + crash'], correct: 0 },
            { title: 'AUTH BYPASS', question: 'MFA = ?', options: ['Multi-Factor Auth', 'Multiple False Auth', 'Main File Access', 'Module Factory Auto'], correct: 0 },
            { title: 'FIREWALL CHECK', question: 'DMZ purpose?', options: ['Buffer zone network', 'Data Management Zone', 'Denial Mode Zero', 'Digital Mesh Zone'], correct: 0 },
            { title: 'PACKET ANALYSIS', question: 'TCP vs UDP?', options: ['Reliable vs Fast', 'Fast vs Reliable', 'Text vs Unicode', 'Trusted vs Unsafe'], correct: 0 },
            { title: 'ENCRYPTION TEST', question: 'AES key size?', options: ['128/192/256 bits', '64/128 bits', '512 bits only', '1024 bits'], correct: 0 },
            { title: 'MALWARE SCAN', question: 'Trojan definition?', options: ['Disguised malware', 'Replicating virus', 'System slowdown', 'Network worm'], correct: 0 },
            { title: 'PENETRATION', question: 'Phishing uses?', options: ['Social engineering', 'Code injection', 'Buffer overflow', 'DDoS attack'], correct: 0 },
            { title: 'PRIVILEGE CHECK', question: 'Sudo allows?', options: ['Root execution', 'Network access', 'File deletion', 'System shutdown'], correct: 0 },
            { title: 'HASH FORENSICS', question: 'MD5 is now?', options: ['Cryptographically broken', 'Still secure', 'Quantum safe', 'Industry standard'], correct: 0 },
            { title: 'VIRUS DETECTION', question: 'Polymorphic virus?', options: ['Changes code each time', 'Spreads via email', 'Encrypts files', 'Uses macro scripts'], correct: 0 },
            { title: 'API SECURITY', question: 'REST security?', options: ['HTTPS + tokens', 'Password only', 'IP whitelist', 'No auth needed'], correct: 0 },
            { title: 'BIOMETRIC AUTH', question: 'Two-factor includes?', options: ['Fingerprint + code', 'Username + password', 'Email + SMS', 'PIN + card'], correct: 0 },
            { title: 'DATA EXFILTRATION', question: 'VPN masks?', options: ['IP address', 'Username', 'Device ID', 'Encryption key'], correct: 0 },
            { title: 'REVERSE SHELL', question: 'Remote access via?', options: ['Reverse connection', 'SSH port', 'RDP protocol', 'HTTP tunnel'], correct: 0 },
            { title: 'BACKDOOR SCAN', question: 'Backdoor purpose?', options: ['Unauthorized access', 'System optimization', 'User authentication', 'Data compression'], correct: 0 },
            { title: 'SESSION HIJACKING', question: 'HTTPS prevents?', options: ['Man-in-middle attacks', 'DDoS attacks', 'Brute force', 'Social engineering'], correct: 0 },
            { title: 'SQL HARDENING', question: 'Parameterized query?', options: ['Prevents injection', 'Speeds query', 'Reduces size', 'Encrypts data'], correct: 0 },
            { title: 'FOOTPRINT CHECK', question: 'Reconnaissance = ?', options: ['Information gathering', 'Active attack', 'Code execution', 'Network blocking'], correct: 0 },
            { title: 'PAYLOAD ANALYSIS', question: 'Shellcode executes?', options: ['Raw machine code', 'Script commands', 'Network packets', 'System files'], correct: 0 },
            { title: 'PUBLIC KEY', question: 'Asymmetric crypto?', options: ['Two different keys', 'One shared key', 'No encryption', 'Quantum based'], correct: 0 },
            { title: 'CERT VALIDATION', question: 'SSL certificate chains?', options: ['Root to leaf', 'Peer to peer', 'Client to server', 'Point to point'], correct: 0 },
            { title: 'FORENSIC SCAN', question: 'Log tampering risk?', options: ['False evidence', 'System crash', 'Data loss', 'User lockout'], correct: 0 },
            { title: 'DEFENSE SYSTEM', question: 'IDS vs IPS?', options: ['Detect vs Prevent', 'Inspect vs Protect', 'Monitor vs Log', 'Alert vs Block'], correct: 0 }
        ];

        // ============== 3D RENDERING ==============
        function project3D(pos) {
            const relPos = pos.sub(camera.pos);
            
            const forward = camera.getForward();
            const right = camera.getRight();
            const up = new Vec3(0, 1, 0);
            
            const depth = relPos.dot(forward);
            const screenX = relPos.dot(right);
            const screenY = relPos.dot(up);
            
            if (depth <= 0.1) return null;
            
            const scale = (canvas.height / 2) / Math.tan((camera.fov / 2) * Math.PI / 180);
            const x = canvas.width / 2 + (screenX / depth) * scale;
            const y = canvas.height / 2 - (screenY / depth) * scale;
            
            return { x, y, depth };
        }

        function drawCube(pos, size, color, depth) {
            const half = size / 2;
            const corners = [
                pos.add(new Vec3(-half, -half, -half)),
                pos.add(new Vec3(half, -half, -half)),
                pos.add(new Vec3(half, -half, half)),
                pos.add(new Vec3(-half, -half, half)),
                pos.add(new Vec3(-half, half, -half)),
                pos.add(new Vec3(half, half, -half)),
                pos.add(new Vec3(half, half, half)),
                pos.add(new Vec3(-half, half, half))
            ];
            
            const proj = corners.map(c => {
                const p = project3D(c);
                return p || { x: -1000, y: -1000, depth: 99999 };
            });
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            const edges = [
                [0,1], [1,2], [2,3], [3,0],
                [4,5], [5,6], [6,7], [7,4],
                [0,4], [1,5], [2,6], [3,7]
            ];
            
            edges.forEach(([a, b]) => {
                if (proj[a] && proj[b]) {
                    ctx.beginPath();
                    ctx.moveTo(proj[a].x, proj[a].y);
                    ctx.lineTo(proj[b].x, proj[b].y);
                    ctx.stroke();
                }
            });
        }

        function drawTerrain() {
            const gridSize = 5;
            const renderDist = 80;
            
            const startX = Math.floor((camera.pos.x - renderDist) / gridSize) * gridSize;
            const startZ = Math.floor((camera.pos.z - renderDist) / gridSize) * gridSize;
            const endX = startX + renderDist * 2;
            const endZ = startZ + renderDist * 2;
            
            const tiles = [];
            
            for (let x = startX; x < endX; x += gridSize) {
                for (let z = startZ; z < endZ; z += gridSize) {
                    const h1 = worldNoise.getHeight(x, z);
                    const h2 = worldNoise.getHeight(x + gridSize, z);
                    const h3 = worldNoise.getHeight(x + gridSize, z + gridSize);
                    const h4 = worldNoise.getHeight(x, z + gridSize);
                    const avgH = (h1 + h2 + h3 + h4) / 4;
                    
                    const p1 = project3D(new Vec3(x, h1, z));
                    const p2 = project3D(new Vec3(x + gridSize, h2, z));
                    const p3 = project3D(new Vec3(x + gridSize, h3, z + gridSize));
                    const p4 = project3D(new Vec3(x, h4, z + gridSize));
                    
                    if (p1 && p2 && p3 && p4) {
                        const terrain = worldNoise.getTerrain(x, z);
                        let color = '#00ff41';
                        if (terrain === 'water') color = '#0088ff';
                        if (terrain === 'dirt') color = '#664400';
                        if (terrain === 'stone') color = '#888888';
                        
                        tiles.push({
                            points: [p1, p2, p3, p4],
                            depth: (p1.depth + p2.depth + p3.depth + p4.depth) / 4,
                            color
                        });
                    }
                }
            }
            
            tiles.sort((a, b) => a.depth - b.depth);
            
            tiles.forEach(tile => {
                ctx.fillStyle = tile.color;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(tile.points[0].x, tile.points[0].y);
                ctx.lineTo(tile.points[1].x, tile.points[1].y);
                ctx.lineTo(tile.points[2].x, tile.points[2].y);
                ctx.lineTo(tile.points[3].x, tile.points[3].y);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#00ff41';
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        function drawNPCCharacter(pos, npc) {
            // Subtle animation based on NPC's animation offset
            const animTime = Date.now() * 0.001 + npc.animationOffset;
            const legSwing = Math.sin(animTime * 2) * 0.2; // Leg swing animation
            const bobbing = Math.sin(animTime * 1.5) * 0.1; // Vertical bobbing
            const armSwing = Math.cos(animTime * 1.8) * 0.15; // Arm swing
            
            const headPos = pos.add(new Vec3(0, 2.0 + bobbing, 0));
            const neckPos = pos.add(new Vec3(0, 1.5 + bobbing, 0));
            const torsoPos = pos.add(new Vec3(0, 0.9 + bobbing * 0.8, 0));
            const waistPos = pos.add(new Vec3(0, 0.1 + bobbing * 0.5, 0));
            const leftShoulderPos = pos.add(new Vec3(-0.7, 1.3, 0));
            const rightShoulderPos = pos.add(new Vec3(0.7, 1.3, 0));
            const leftArmPos = pos.add(new Vec3(-0.8 + armSwing * 0.3, 0.7, 0));
            const rightArmPos = pos.add(new Vec3(0.8 - armSwing * 0.3, 0.7, 0));
            const leftHandPos = pos.add(new Vec3(-0.9 + armSwing * 0.4, 0.3, 0));
            const rightHandPos = pos.add(new Vec3(0.9 - armSwing * 0.4, 0.3, 0));
            const leftLegPos = pos.add(new Vec3(-0.3 + legSwing, -0.8, 0));
            const rightLegPos = pos.add(new Vec3(0.3 - legSwing, -0.8, 0));
            const leftFootPos = pos.add(new Vec3(-0.3 + legSwing, -1.5, 0));
            const rightFootPos = pos.add(new Vec3(0.3 - legSwing, -1.5, 0));
            
            // Project all positions
            const projHead = project3D(headPos);
            const projNeck = project3D(neckPos);
            const projTorso = project3D(torsoPos);
            const projWaist = project3D(waistPos);
            const projLeftShoulder = project3D(leftShoulderPos);
            const projRightShoulder = project3D(rightShoulderPos);
            const projLeftArm = project3D(leftArmPos);
            const projRightArm = project3D(rightArmPos);
            const projLeftHand = project3D(leftHandPos);
            const projRightHand = project3D(rightHandPos);
            const projLeftLeg = project3D(leftLegPos);
            const projRightLeg = project3D(rightLegPos);
            const projLeftFoot = project3D(leftFootPos);
            const projRightFoot = project3D(rightFootPos);
            
            if (!projHead || !projTorso) return;
            
            // Draw legs (back layer)
            ctx.strokeStyle = npc.primaryColor;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            // Left leg
            if (projWaist && projLeftLeg && projLeftFoot) {
                ctx.beginPath();
                ctx.moveTo(projWaist.x - 3, projWaist.y);
                ctx.lineTo(projLeftLeg.x, projLeftLeg.y);
                ctx.lineTo(projLeftFoot.x, projLeftFoot.y);
                ctx.stroke();
            }
            
            // Right leg
            if (projWaist && projRightLeg && projRightFoot) {
                ctx.beginPath();
                ctx.moveTo(projWaist.x + 3, projWaist.y);
                ctx.lineTo(projRightLeg.x, projRightLeg.y);
                ctx.lineTo(projRightFoot.x, projRightFoot.y);
                ctx.stroke();
            }
            
            // Draw arms (middle layer)
            ctx.lineWidth = 3;
            
            // Left arm
            if (projLeftShoulder && projLeftArm && projLeftHand) {
                ctx.beginPath();
                ctx.moveTo(projLeftShoulder.x, projLeftShoulder.y);
                ctx.lineTo(projLeftArm.x, projLeftArm.y);
                ctx.lineTo(projLeftHand.x, projLeftHand.y);
                ctx.stroke();
            }
            
            // Right arm
            if (projRightShoulder && projRightArm && projRightHand) {
                ctx.beginPath();
                ctx.moveTo(projRightShoulder.x, projRightShoulder.y);
                ctx.lineTo(projRightArm.x, projRightArm.y);
                ctx.lineTo(projRightHand.x, projRightHand.y);
                ctx.stroke();
            }
            
            // Draw pants/lower body
            if (projWaist && projLeftLeg && projRightLeg) {
                ctx.fillStyle = npc.accentColor;
                ctx.globalAlpha = 0.8;
                ctx.fillRect(projWaist.x - 4, projWaist.y, 8, (projLeftLeg.y - projWaist.y) / 2);
                ctx.globalAlpha = 1;
            }
            
            // Draw torso/chest piece with more detail
            if (projTorso && projWaist) {
                ctx.fillStyle = npc.primaryColor;
                ctx.globalAlpha = 0.85;
                const torsoHeight = Math.abs(projWaist.y - projTorso.y);
                ctx.fillRect(projTorso.x - 7, projTorso.y, 14, torsoHeight);
                
                // Chest panel/tech detail with better proportions
                ctx.fillStyle = npc.accentColor;
                ctx.globalAlpha = 0.7;
                ctx.fillRect(projTorso.x - 4, projTorso.y + 1, 8, torsoHeight - 2);
                
                // Tech lines on chest
                ctx.strokeStyle = npc.accentColor;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5;
                for (let i = 0; i < 3; i++) {
                    const y = projTorso.y + (torsoHeight / 3) * (i + 0.5);
                    ctx.beginPath();
                    ctx.moveTo(projTorso.x - 3, y);
                    ctx.lineTo(projTorso.x + 3, y);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // Draw shoulders/jacket with better shape
            if (projLeftShoulder && projRightShoulder && projNeck) {
                ctx.fillStyle = npc.primaryColor;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(projLeftShoulder.x - 2, projLeftShoulder.y);
                ctx.lineTo(projRightShoulder.x + 2, projRightShoulder.y);
                ctx.lineTo(projRightShoulder.x + 1, projRightShoulder.y - 4);
                ctx.lineTo(projNeck.x + 3, projNeck.y - 1);
                ctx.lineTo(projNeck.x - 3, projNeck.y - 1);
                ctx.lineTo(projLeftShoulder.x - 1, projLeftShoulder.y - 4);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Draw hands
            if (projLeftHand && projRightHand) {
                ctx.fillStyle = npc.skinColor;
                ctx.beginPath();
                ctx.arc(projLeftHand.x, projLeftHand.y, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(projRightHand.x, projRightHand.y, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw feet with better proportions
            if (projLeftFoot && projRightFoot) {
                ctx.fillStyle = '#333333';
                ctx.fillRect(projLeftFoot.x - 2, projLeftFoot.y, 4, 2.5);
                ctx.fillRect(projRightFoot.x - 2, projRightFoot.y, 4, 2.5);
            }
            
            // Draw head with skin
            if (projHead) {
                // Head sphere
                ctx.fillStyle = npc.skinColor;
                ctx.globalAlpha = 0.95;
                ctx.beginPath();
                ctx.arc(projHead.x, projHead.y, 9, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Hair/top detail
                ctx.fillStyle = '#333333';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(projHead.x - 8, projHead.y);
                ctx.quadraticCurveTo(projHead.x, projHead.y - 10, projHead.x + 8, projHead.y);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Helmet/visor overlay for cyborg/agent
                if (npc.class === 'cyborg') {
                    ctx.strokeStyle = '#ff6699';
                    ctx.lineWidth = 2.5;
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    ctx.arc(projHead.x, projHead.y, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Visor glow
                    ctx.fillStyle = '#ff6699';
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(projHead.x, projHead.y, 10.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (npc.class === 'agent') {
                    ctx.strokeStyle = npc.accentColor;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(projHead.x, projHead.y, 10.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
            
            // Draw eyes with tech glow
            if (projHead) {
                const eyeY = projHead.y - 2;
                const eyeGlow = Math.sin(animTime * 3) * 0.5 + 1; // Pulsing glow
                
                ctx.fillStyle = '#00ff00';
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(projHead.x - 3.5, eyeY, 1.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(projHead.x + 3.5, eyeY, 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye glow
                ctx.strokeStyle = '#00ff41';
                ctx.lineWidth = 0.8;
                ctx.globalAlpha = 0.6 * eyeGlow;
                ctx.beginPath();
                ctx.arc(projHead.x - 3.5, eyeY, 3.5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(projHead.x + 3.5, eyeY, 3.5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
            
            // Draw class-specific accessories
            if (npc.class === 'hacker' && projRightHand) {
                // Draw laptop/device
                ctx.fillStyle = '#00ffff';
                ctx.globalAlpha = 0.8;
                ctx.fillRect(projRightHand.x - 4, projRightHand.y - 3, 8, 6);
                // Screen glow
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5;
                ctx.strokeRect(projRightHand.x - 4, projRightHand.y - 3, 8, 6);
                ctx.globalAlpha = 1;
            } else if (npc.class === 'cyborg' && projRightHand) {
                // Draw glowing weapon/tool
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2.5;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(projRightHand.x, projRightHand.y);
                ctx.lineTo(projRightHand.x + 6, projRightHand.y - 4);
                ctx.stroke();
                // Weapon glow
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.4;
                ctx.stroke();
                ctx.globalAlpha = 1;
            } else if (npc.class === 'ghost' && projRightHand) {
                // Draw spectral effect
                ctx.strokeStyle = '#ff10f0';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(projRightHand.x, projRightHand.y, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
            
            // Aura glow based on class with pulsing effect
            if (projHead) {
                const glowIntensity = Math.sin(animTime * 2.5) * 0.2 + 0.4;
                ctx.strokeStyle = npc.accentColor;
                ctx.lineWidth = 1;
                ctx.globalAlpha = glowIntensity;
                ctx.beginPath();
                ctx.arc(projHead.x, projHead.y, 16, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
            
            // Name tag with bracket styling
            if (projHead) {
                ctx.fillStyle = npc.primaryColor;
                ctx.font = 'bold 9px monospace';
                const homeIndicator = npc.atHome ? ' [HOME]' : '';
                ctx.fillText('[ ' + npc.name + homeIndicator + ' ]', projHead.x - 30, projHead.y - 22);
                
                // Class indicator
                ctx.fillStyle = npc.accentColor;
                ctx.font = '8px monospace';
                ctx.fillText(npc.class.toUpperCase(), projHead.x - 20, projHead.y + 18);
                
                // If NPC is at home, draw a house indicator below
                if (npc.atHome) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.globalAlpha = 0.6;
                    ctx.font = 'bold 10px monospace';
                    ctx.fillText('âŒ‚', projHead.x - 3, projHead.y + 30);
                    ctx.globalAlpha = 1;
                }
            }
        }

        function drawBuilding(building) {
            const half_w = building.width / 2;
            const half_d = building.depth / 2;
            const h = building.height;
            const rh = building.roofHeight || 2;
            
            // Base corners
            const corners = [
                building.pos.add(new Vec3(-half_w, 0, -half_d)),
                building.pos.add(new Vec3(half_w, 0, -half_d)),
                building.pos.add(new Vec3(half_w, 0, half_d)),
                building.pos.add(new Vec3(-half_w, 0, half_d)),
                building.pos.add(new Vec3(-half_w, h, -half_d)),
                building.pos.add(new Vec3(half_w, h, -half_d)),
                building.pos.add(new Vec3(half_w, h, half_d)),
                building.pos.add(new Vec3(-half_w, h, half_d))
            ];
            
            // Roof peak
            const roofPeaks = [
                building.pos.add(new Vec3(0, h + rh, -half_d)),
                building.pos.add(new Vec3(0, h + rh, half_d))
            ];
            
            const proj = corners.map(c => {
                const p = project3D(c);
                return p || { x: -1000, y: -1000, depth: 99999 };
            });
            
            const projRoof = roofPeaks.map(c => {
                const p = project3D(c);
                return p || { x: -1000, y: -1000, depth: 99999 };
            });
            
            // Draw walls with shading
            const walls = [
                { indices: [0, 1, 5, 4], alpha: 0.85, color: building.color }, // Front
                { indices: [1, 2, 6, 5], alpha: 0.70, color: building.color }, // Right
                { indices: [3, 0, 4, 7], alpha: 0.70, color: building.color }, // Left
                { indices: [2, 3, 7, 6], alpha: 0.75, color: building.color }  // Back
            ];
            
            walls.forEach(wall => {
                const [a, b, c, d] = wall.indices;
                ctx.fillStyle = wall.color;
                ctx.globalAlpha = wall.alpha;
                ctx.beginPath();
                ctx.moveTo(proj[a].x, proj[a].y);
                ctx.lineTo(proj[b].x, proj[b].y);
                ctx.lineTo(proj[c].x, proj[c].y);
                ctx.lineTo(proj[d].x, proj[d].y);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#00ff41';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.4;
                ctx.stroke();
            });
            
            // Draw pitched roof
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#333333';
            
            // Front roof face
            ctx.beginPath();
            ctx.moveTo(proj[4].x, proj[4].y); // Top-front-left
            ctx.lineTo(proj[5].x, proj[5].y); // Top-front-right
            ctx.lineTo(projRoof[0].x, projRoof[0].y); // Front peak
            ctx.closePath();
            ctx.fill();
            
            // Back roof face
            ctx.beginPath();
            ctx.moveTo(proj[6].x, proj[6].y); // Top-back-right
            ctx.lineTo(proj[7].x, proj[7].y); // Top-back-left
            ctx.lineTo(projRoof[1].x, projRoof[1].y); // Back peak
            ctx.closePath();
            ctx.fill();
            
            ctx.globalAlpha = 1;
            
            // Draw windows on front face
            const [p0, p1, p5, p4] = [proj[0], proj[1], proj[5], proj[4]];
            ctx.fillStyle = '#00ffff';
            ctx.globalAlpha = 0.5;
            
            const winW = (p1.x - p0.x) / 4;
            const winH = (p4.y - p0.y) / 2.5;
            
            // Window positions
            const windowPositions = [
                [p0.x + winW * 0.5, p0.y + winH * 0.4],
                [p0.x + winW * 2.5, p0.y + winH * 0.4],
                [p0.x + winW * 0.5, p0.y + winH * 1.5],
                [p0.x + winW * 2.5, p0.y + winH * 1.5]
            ];
            
            windowPositions.forEach(([wx, wy]) => {
                ctx.fillRect(wx, wy, winW * 0.6, winH * 0.4);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.7;
                ctx.strokeRect(wx, wy, winW * 0.6, winH * 0.4);
            });
            
            // Draw door on front face
            const doorX = p0.x + (p1.x - p0.x) / 2 - (winW * 0.8) / 2;
            const doorY = p0.y + (p4.y - p0.y) - winH * 0.9;
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#664422';
            ctx.fillRect(doorX, doorY, winW * 0.8, winH * 0.9);
            
            // Door frame and knob
            ctx.strokeStyle = '#884433';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.9;
            ctx.strokeRect(doorX, doorY, winW * 0.8, winH * 0.9);
            
            ctx.fillStyle = '#ffaa00';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(doorX + winW * 0.65, doorY + winH * 0.45, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
        }

        function drawNPCs() {
            npcs.forEach(npc => {
                npc.distToPlayer = camera.pos.dist(npc.pos);
                drawNPCCharacter(npc.pos, npc);
                
                const isClose = npc.distToPlayer < 15;
                if (isClose) {
                    const proj = project3D(npc.pos);
                    if (proj && proj.depth > 0) {
                        ctx.strokeStyle = '#ff10f0';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, 35, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
            });
        }

        function drawBuildings() {
            const renderDist = 80;
            const visibleBuildings = buildings.filter(b => {
                const dist = camera.pos.dist(b.pos);
                return dist < renderDist;
            });
            
            visibleBuildings.sort((a, b) => {
                const distA = camera.pos.dist(a.pos);
                const distB = camera.pos.dist(b.pos);
                return distA - distB;
            });
            
            visibleBuildings.forEach(building => {
                drawBuilding(building);
            });
        }

        function drawPlayer() {
            const playerSize = 1.5;
            const projHead = project3D(camera.pos.add(new Vec3(0, 1.5, 0)));
            const projBody = project3D(camera.pos.add(new Vec3(0, 0.5, 0)));
            
            if (projHead && projBody) {
                ctx.fillStyle = '#39ff14';
                ctx.beginPath();
                ctx.arc(projHead.x, projHead.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#00ff41';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(projHead.x, projHead.y, 12, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // ============== MINIMAP ==============
        function drawMinimap() {
            const mmWidth = minimapCanvas.width;
            const mmHeight = minimapCanvas.height;
            const scale = 2;
            
            minimapCtx.fillStyle = '#0a0e27';
            minimapCtx.fillRect(0, 0, mmWidth, mmHeight);
            
            minimapCtx.strokeStyle = '#00ff41';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(0, 0, mmWidth, mmHeight);
            
            // Draw NPCs
            minimapCtx.fillStyle = '#ff10f0';
            npcs.forEach(npc => {
                const x = (npc.pos.x / 100) * mmWidth;
                const y = (npc.pos.z / 100) * mmHeight;
                minimapCtx.fillRect(x - 2, y - 2, 4, 4);
            });
            
            // Draw player
            minimapCtx.fillStyle = '#00ff41';
            const px = (camera.pos.x / 100) * mmWidth;
            const py = (camera.pos.z / 100) * mmHeight;
            minimapCtx.fillRect(px - 3, py - 3, 6, 6);
            
            // Draw direction
            const forward = camera.getForward();
            minimapCtx.strokeStyle = '#00ff41';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(px, py);
            minimapCtx.lineTo(px + forward.x * 10, py + forward.z * 10);
            minimapCtx.stroke();
        }

        // ============== INTERACTION ==============
        function checkNPCProximity() {
            npcs.forEach(npc => {
                const dist = camera.pos.dist(npc.pos);
                if (dist < 10 && !gameState.challengeActive && !npc.active) {
                    npc.active = true;
                    showChallenge(npc);
                }
            });
        }

        function showChallenge(npc) {
            const challenge = challenges[Math.floor(Math.random() * challenges.length)];
            gameState.currentChallenge = { ...challenge, npc };
            gameState.selectedOption = null;
            gameState.challengeActive = true;
            
            // Mark which building this challenge is for
            if (npc.houseIndex >= 0) {
                gameState.currentChallenge.buildingIndex = npc.houseIndex;
            }
            
            document.getElementById('challengeTitle').textContent = challenge.title + ' (' + npc.name + ')';
            document.getElementById('challengeText').textContent = challenge.question;
            
            const optionsGroup = document.getElementById('optionsGroup');
            optionsGroup.innerHTML = '';
            challenge.options.forEach((opt, idx) => {
                const label = document.createElement('label');
                label.className = 'option-label';
                label.innerHTML = `<input type="radio" name="option" value="${idx}"><span class="option-text">${String.fromCharCode(65+idx)}) ${opt}</span>`;
                label.addEventListener('change', () => { gameState.selectedOption = idx; });
                optionsGroup.appendChild(label);
            });
            
            document.getElementById('modalBackdrop').classList.add('active');
            gameState.challengeTime = 60;
            gameState.challengeStart = Date.now();
        }

        function submitChallenge() {
            if (gameState.selectedOption === null) {
                showToast('SELECT OPTION', 'failure');
                return;
            }
            
            const isCorrect = gameState.selectedOption === gameState.currentChallenge.correct;
            gameState.totalAttempts++;
            
            if (isCorrect) {
                gameState.correctAnswers++;
                gameState.systemsMet++;
                gameState.score += 50;
                gameState.currentChallenge.npc.active = false;
                
                // Mark the building as challenged
                if (gameState.currentChallenge.buildingIndex >= 0) {
                    buildings[gameState.currentChallenge.buildingIndex].challengeCompleted = true;
                }
                
                showToast('+50 POINTS', 'success');
            } else {
                gameState.score = Math.max(0, gameState.score - 10);
                showToast('-10 POINTS', 'failure');
            }
            
            closeChallenge();
        }

        function closeChallenge() {
            gameState.challengeActive = false;
            document.getElementById('modalBackdrop').classList.remove('active');
        }

        function showToast(msg, type) {
            const toast = document.createElement('div');
            toast.className = 'toast ' + (type === 'failure' ? 'failure' : '');
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function setMoveTarget(screenX, screenY) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const relX = screenX - centerX;
            const relY = screenY - centerY;
            
            const forward = camera.getForward();
            const right = camera.getRight();
            
            const screenDist = Math.sqrt(relX*relX + relY*relY);
            const moveDir = forward.mul(-relY / 200).add(right.mul(relX / 200)).normalize();
            const targetDist = Math.min(30, screenDist / 10);
            
            movement.targetPos = camera.pos.add(moveDir.mul(targetDist));
            movement.targetPos.x = Math.max(0, Math.min(100, movement.targetPos.x));
            movement.targetPos.z = Math.max(0, Math.min(100, movement.targetPos.z));
            movement.isMoving = true;
        }

        // ============== UPDATE ==============
        function updateCamera() {
            const speed = 35; // units per second
            const stopDist = 0.5;
            
            if (movement.isMoving && movement.targetPos) {
                const diff = movement.targetPos.sub(camera.pos);
                const dist = Math.sqrt(diff.x*diff.x + diff.z*diff.z);
                
                if (dist > stopDist) {
                    const dir = diff.normalize();
                    camera.pos = camera.pos.add(dir.mul(speed * 0.016));
                    gameState.playerSpeed = speed * 0.016;
                } else {
                    movement.isMoving = false;
                    gameState.playerSpeed = 0;
                }
            } else {
                gameState.playerSpeed = 0;
            }
            
            // Clamp position
            camera.pos.x = Math.max(0, Math.min(100, camera.pos.x));
            camera.pos.z = Math.max(0, Math.min(100, camera.pos.z));
            camera.pos.y = Math.max(-5, Math.min(20, camera.pos.y));
            
            // Update euler with mouse
            camera.euler.y += mouse.dx;
            camera.euler.x += mouse.dy;
            camera.euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.euler.x));
            mouse.dx = 0;
            mouse.dy = 0;
        }

        function updateHUD() {
            document.getElementById('posDisplay').textContent = 
                camera.pos.x.toFixed(1) + ', ' + 
                camera.pos.y.toFixed(1) + ', ' + 
                camera.pos.z.toFixed(1);
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('systemsDisplay').textContent = gameState.systemsMet + '/8';
            document.getElementById('speedDisplay').textContent = (gameState.playerSpeed * 1000).toFixed(0);
            
            // Update quest progress
            const completedBuildings = buildings.filter(b => b.challengeCompleted).length;
            const totalBuildings = Math.min(buildings.length, 8);
            let questHTML = `[${completedBuildings}/${totalBuildings}] SYSTEMS BREACHED<br>`;
            
            for (let i = 0; i < Math.min(buildings.length, 8); i++) {
                const b = buildings[i];
                const status = b.challengeCompleted ? 'âœ“' : 'â—‹';
                const color = b.challengeCompleted ? '#39ff14' : '#666666';
                questHTML += `<div style="color: ${color};">${status} NODE_${String.fromCharCode(65 + i)}</div>`;
            }
            
            document.getElementById('buildingStatus').innerHTML = questHTML;
        }

        // ============== RENDER LOOP ==============
        function render() {
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawTerrain();
            drawBuildings();
            drawNPCs();
            drawPlayer();
            
            // Debug info
            ctx.fillStyle = '#00ff41';
            ctx.font = '12px monospace';
            ctx.fillText('FPS: ' + Math.round(1000/16), canvas.width - 120, 30);
        }

        function gameLoop() {
            updateCamera();
            checkNPCProximity();
            updateHUD();
            drawMinimap();
            render();
            
            if (gameState.challengeActive) {
                const elapsed = (Date.now() - gameState.challengeStart) / 1000;
                const timeLeft = Math.max(0, 60 - elapsed);
                const progress = timeLeft / 60;
                document.getElementById('timerFill').style.width = (progress * 100) + '%';
                
                if (timeLeft <= 0) {
                    closeChallenge();
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        document.getElementById('submitBtn').addEventListener('click', submitChallenge);
        document.getElementById('cancelBtn').addEventListener('click', closeChallenge);

        gameLoop();
    </script>
</body>
</html>
