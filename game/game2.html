<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DATASCAPE EXPLORATION</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0e27; font-family: 'Courier New', monospace; color: #00ff41; }
        canvas { display: block; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0e27 0%, #1a1e47 100%); }
        .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15) 0%, rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px); animation: scan 0.08s linear infinite; }
        @keyframes scan { 0% { transform: translateY(0); } 100% { transform: translateY(4px); } }
        #hud { position: fixed; top: 20px; left: 20px; z-index: 40; font-size: 13px; line-height: 1.5; text-shadow: 0 0 10px rgba(0,255,65,0.5); background: rgba(10,14,39,0.8); border: 2px solid #00ff41; padding: 12px; }
        .hud-line { color: #00ff41; margin: 3px 0; text-transform: uppercase; }
        .hud-label { color: #ff10f0; }
        .hud-value { color: #00ffff; }
        .crosshair { position: fixed; top: 50%; left: 50%; z-index: 30; transform: translate(-50%, -50%); width: 20px; height: 20px; border: 2px solid #00ff41; }
        .crosshair::before, .crosshair::after { content: ''; position: absolute; background: #00ff41; }
        .crosshair::before { width: 2px; height: 10px; left: 9px; top: -15px; }
        .crosshair::after { width: 10px; height: 2px; left: -15px; top: 9px; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; z-index: 100; }
        .modal-backdrop.active { display: flex; align-items: center; justify-content: center; }
        .challenge-modal { background: rgba(10,14,39,0.98); border: 3px solid #00ff41; padding: 30px; max-width: 550px; width: 90%; box-shadow: 0 0 40px rgba(0,255,65,0.4); }
        .challenge-modal h2 { color: #00ff41; font-size: 20px; margin-bottom: 15px; text-transform: uppercase; text-shadow: -2px 0 0 #ff10f0, 2px 0 0 #00ffff; }
        .challenge-modal p { color: #00ffff; font-size: 14px; margin-bottom: 20px; }
        .timer-bar { width: 100%; height: 10px; background: #0a0e27; border: 2px solid #00ff41; margin-bottom: 20px; overflow: hidden; }
        .timer-fill { height: 100%; background: linear-gradient(90deg, #00ff41, #39ff14); width: 100%; transition: width 0.1s; }
        .option-label { display: flex; padding: 8px; margin: 6px 0; background: rgba(0,255,65,0.05); border: 2px solid #00ff41; cursor: pointer; }
        .option-label:hover { background: rgba(0,255,65,0.15); }
        .option-label input { margin-right: 8px; accent-color: #00ff41; cursor: pointer; }
        .option-text { color: #00ffff; font-size: 13px; }
        button { padding: 8px 16px; background: #0a0e27; color: #00ff41; border: 2px solid #00ff41; font-family: monospace; cursor: pointer; margin-right: 8px; text-transform: uppercase; font-size: 12px; }
        button:hover { background: #00ff41; color: #0a0e27; }
        .toast { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); background: rgba(0,255,65,0.95); color: #0a0e27; padding: 12px 24px; z-index: 101; font-weight: bold; font-size: 12px; }
        .toast.failure { background: rgba(255,0,0,0.95); color: #fff; }
        #minimap { position: fixed; bottom: 20px; right: 20px; width: 150px; height: 150px; border: 2px solid #00ff41; background: rgba(10,14,39,0.9); z-index: 40; }
        .controls { position: fixed; bottom: 20px; left: 20px; z-index: 40; font-size: 11px; background: rgba(10,14,39,0.8); border: 2px solid #00ff41; padding: 8px; color: #00ffff; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="crosshair"></div>

    <div id="hud">
        <div class="hud-line"><span class="hud-label">POS:</span> <span class="hud-value" id="posDisplay">0.0, 0.0, 0.0</span></div>
        <div class="hud-line"><span class="hud-label">SCORE:</span> <span class="hud-value" id="scoreDisplay">0</span></div>
        <div class="hud-line"><span class="hud-label">SYSTEMS:</span> <span class="hud-value" id="systemsDisplay">0/8</span></div>
        <div class="hud-line"><span class="hud-label">SPEED:</span> <span class="hud-value" id="speedDisplay">0.0</span></div>
    </div>

    <div class="controls">
        <div style="color: #ff10f0;">MOVEMENT:</div>
        <div>CLICK/TAP - MOVE</div>
        <div style="color: #ff10f0; margin-top: 4px;">DRAG - LOOK</div>
    </div>

    <canvas id="minimap"></canvas>

    <div id="modalBackdrop" class="modal-backdrop">
        <div class="challenge-modal">
            <h2 id="challengeTitle"></h2>
            <p id="challengeText"></p>
            <div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>
            <div id="optionsGroup"></div>
            <button id="submitBtn">SUBMIT</button>
            <button id="cancelBtn">SKIP</button>
        </div>
    </div>

    <script>
        // ============== MATH & UTILITY ==============
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x; this.y = y; this.z = z;
            }
            clone() { return new Vec3(this.x, this.y, this.z); }
            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            dist(v) {
                const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
                return Math.sqrt(dx*dx + dy*dy + dz*dz);
            }
            normalize() {
                const len = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
                return len > 0 ? new Vec3(this.x/len, this.y/len, this.z/len) : new Vec3();
            }
            dot(v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
        }

        // ============== CANVAS SETUP ==============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ============== CAMERA & INPUT ==============
        const camera = {
            pos: new Vec3(50, 5, 50),
            euler: { x: 0, y: 0 },
            fov: 60,
            getForward() {
                return new Vec3(
                    Math.sin(this.euler.y),
                    0,
                    Math.cos(this.euler.y)
                );
            },
            getRight() {
                return new Vec3(
                    Math.cos(this.euler.y),
                    0,
                    -Math.sin(this.euler.y)
                );
            }
        };

        const mouse = { dx: 0, dy: 0, dragging: false, lastX: 0, lastY: 0, dragDistance: 0, startX: 0, startY: 0 };
        const movement = { targetPos: null, isMoving: false };

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            
            mouse.dragging = true;
            mouse.dragDistance = 0;
            mouse.lastX = screenX;
            mouse.lastY = screenY;
            mouse.startX = screenX;
            mouse.startY = screenY;
        });

        canvas.addEventListener('mouseup', (e) => {
            if (mouse.dragDistance < 10 && !gameState.challengeActive) {
                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                setMoveTarget(screenX, screenY);
            }
            mouse.dragging = false;
            mouse.dragDistance = 0;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!mouse.dragging) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            
            const dx = screenX - mouse.lastX;
            const dy = screenY - mouse.lastY;
            mouse.dragDistance += Math.sqrt(dx*dx + dy*dy);
            
            mouse.dx += dx * 0.002;
            mouse.dy += dy * 0.002;
            
            mouse.lastX = screenX;
            mouse.lastY = screenY;
        });

        canvas.addEventListener('touchstart', (e) => {
            if (gameState.challengeActive) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const screenX = touch.clientX - rect.left;
            const screenY = touch.clientY - rect.top;
            setMoveTarget(screenX, screenY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, false);

        // ============== WORLD GENERATION ==============
        const worldNoise = {
            seed: 12345,
            hash(x, y) {
                let h = this.seed + x * 374761393 ^ y * 668265263;
                h = (h ^ (h >> 13)) * 274761393;
                return ((h ^ (h >> 16)) & 2147483647) / 2147483647;
            },
            perlin2d(x, y) {
                const xi = Math.floor(x), yi = Math.floor(y);
                const xf = x - xi, yf = y - yi;
                const u = xf * xf * (3 - 2*xf), v = yf * yf * (3 - 2*yf);
                
                const n00 = this.hash(xi, yi);
                const n10 = this.hash(xi+1, yi);
                const n01 = this.hash(xi, yi+1);
                const n11 = this.hash(xi+1, yi+1);
                
                const nx0 = n00 + u * (n10 - n00);
                const nx1 = n01 + u * (n11 - n01);
                return nx0 + v * (nx1 - nx0);
            },
            getHeight(x, z) {
                let height = 0;
                height += this.perlin2d(x*0.05, z*0.05) * 3;
                height += this.perlin2d(x*0.1, z*0.1) * 1.5;
                return height;
            },
            getTerrain(x, z) {
                const height = this.getHeight(x, z);
                if (height < -0.5) return 'water';
                if (height < 0.2) return 'dirt';
                if (height < 1) return 'grass';
                return 'stone';
            }
        };

        // ============== GAME STATE ==============
        const gameState = {
            score: 0,
            systemsMet: 0,
            totalAttempts: 0,
            correctAnswers: 0,
            challengeActive: false,
            selectedOption: null,
            playerSpeed: 0
        };

        // ============== NPCs ==============
        const npcs = [];
        const npcPositions = [
            {x: 30, z: 30, name: 'NODE_A'},
            {x: 70, z: 40, name: 'NODE_B'},
            {x: 50, z: 70, name: 'NODE_C'},
            {x: 20, z: 60, name: 'NODE_D'},
            {x: 80, z: 20, name: 'NODE_E'},
            {x: 60, z: 55, name: 'NODE_F'},
            {x: 35, z: 45, name: 'NODE_G'},
            {x: 75, z: 75, name: 'NODE_H'}
        ];

        npcPositions.forEach(pos => {
            const h = worldNoise.getHeight(pos.x, pos.z);
            npcs.push({
                pos: new Vec3(pos.x, h + 2, pos.z),
                name: pos.name,
                active: false,
                distToPlayer: 999,
                color: ['#ff10f0', '#00ffff', '#39ff14', '#ffff00'][Math.floor(Math.random() * 4)]
            });
        });

        // ============== BUILDINGS ==============
        const buildings = [];
        function generateBuildings() {
            for (let i = 0; i < 12; i++) {
                const x = Math.random() * 100;
                const z = Math.random() * 100;
                const h = worldNoise.getHeight(x, z);
                const terrain = worldNoise.getTerrain(x, z);
                
                if (terrain !== 'water' && terrain !== 'stone') {
                    buildings.push({
                        pos: new Vec3(x, h, z),
                        width: 3 + Math.random() * 4,
                        depth: 4 + Math.random() * 5,
                        height: 4 + Math.random() * 3,
                        color: ['#ff4444', '#4444ff', '#44ff44', '#ffff44'][Math.floor(Math.random() * 4)],
                        distToPlayer: 999
                    });
                }
            }
        }
        generateBuildings();

        // ============== CHALLENGE POOL ==============
        const challenges = [
            { title: 'EXPLOIT DETECTED', question: 'SQL injection targets?', options: ['Database', 'Firewall', 'Memory', 'Cache'], correct: 0 },
            { title: 'BREACH PROTOCOL', question: 'Zero-day definition?', options: ['Unknown exploit', 'Old bug', 'Documented flaw', 'Feature'], correct: 0 },
            { title: 'CRYPTO ANALYSIS', question: 'SHA256 output size?', options: ['256 bits', '256 bytes', '128 bits', '512 bits'], correct: 0 },
            { title: 'NETWORK TRACE', question: 'HTTPS default port?', options: ['443', '80', '8080', '22'], correct: 0 },
            { title: 'MEMORY DUMP', question: 'Buffer overflow risk?', options: ['Unbounded copy', 'Encryption', 'Checksum', 'Sorting'], correct: 0 },
            { title: 'CODE REVIEW', question: 'CSRF protection?', options: ['Token validation', 'Encryption', 'Rate limit', 'Logging'], correct: 0 },
            { title: 'INTRUSION LOG', question: 'Rootkit operates in?', options: ['Kernel space', 'User space', 'Ring 3', 'Application'], correct: 0 },
            { title: 'THREAT SCAN', question: 'Ransomware = ?', options: ['Encrypt + ransom', 'Copy + steal', 'Delete + log', 'Stall + crash'], correct: 0 }
        ];

        // ============== 3D RENDERING ==============
        function project3D(pos) {
            const relPos = pos.sub(camera.pos);
            
            const forward = camera.getForward();
            const right = camera.getRight();
            const up = new Vec3(0, 1, 0);
            
            const depth = relPos.dot(forward);
            const screenX = relPos.dot(right);
            const screenY = relPos.dot(up);
            
            if (depth <= 0.1) return null;
            
            const scale = (canvas.height / 2) / Math.tan((camera.fov / 2) * Math.PI / 180);
            const x = canvas.width / 2 + (screenX / depth) * scale;
            const y = canvas.height / 2 - (screenY / depth) * scale;
            
            return { x, y, depth };
        }

        function drawCube(pos, size, color, depth) {
            const half = size / 2;
            const corners = [
                pos.add(new Vec3(-half, -half, -half)),
                pos.add(new Vec3(half, -half, -half)),
                pos.add(new Vec3(half, -half, half)),
                pos.add(new Vec3(-half, -half, half)),
                pos.add(new Vec3(-half, half, -half)),
                pos.add(new Vec3(half, half, -half)),
                pos.add(new Vec3(half, half, half)),
                pos.add(new Vec3(-half, half, half))
            ];
            
            const proj = corners.map(c => {
                const p = project3D(c);
                return p || { x: -1000, y: -1000, depth: 99999 };
            });
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            const edges = [
                [0,1], [1,2], [2,3], [3,0],
                [4,5], [5,6], [6,7], [7,4],
                [0,4], [1,5], [2,6], [3,7]
            ];
            
            edges.forEach(([a, b]) => {
                if (proj[a] && proj[b]) {
                    ctx.beginPath();
                    ctx.moveTo(proj[a].x, proj[a].y);
                    ctx.lineTo(proj[b].x, proj[b].y);
                    ctx.stroke();
                }
            });
        }

        function drawTerrain() {
            const gridSize = 5;
            const renderDist = 80;
            
            const startX = Math.floor((camera.pos.x - renderDist) / gridSize) * gridSize;
            const startZ = Math.floor((camera.pos.z - renderDist) / gridSize) * gridSize;
            const endX = startX + renderDist * 2;
            const endZ = startZ + renderDist * 2;
            
            const tiles = [];
            
            for (let x = startX; x < endX; x += gridSize) {
                for (let z = startZ; z < endZ; z += gridSize) {
                    const h1 = worldNoise.getHeight(x, z);
                    const h2 = worldNoise.getHeight(x + gridSize, z);
                    const h3 = worldNoise.getHeight(x + gridSize, z + gridSize);
                    const h4 = worldNoise.getHeight(x, z + gridSize);
                    const avgH = (h1 + h2 + h3 + h4) / 4;
                    
                    const p1 = project3D(new Vec3(x, h1, z));
                    const p2 = project3D(new Vec3(x + gridSize, h2, z));
                    const p3 = project3D(new Vec3(x + gridSize, h3, z + gridSize));
                    const p4 = project3D(new Vec3(x, h4, z + gridSize));
                    
                    if (p1 && p2 && p3 && p4) {
                        const terrain = worldNoise.getTerrain(x, z);
                        let color = '#00ff41';
                        if (terrain === 'water') color = '#0088ff';
                        if (terrain === 'dirt') color = '#664400';
                        if (terrain === 'stone') color = '#888888';
                        
                        tiles.push({
                            points: [p1, p2, p3, p4],
                            depth: (p1.depth + p2.depth + p3.depth + p4.depth) / 4,
                            color
                        });
                    }
                }
            }
            
            tiles.sort((a, b) => a.depth - b.depth);
            
            tiles.forEach(tile => {
                ctx.fillStyle = tile.color;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(tile.points[0].x, tile.points[0].y);
                ctx.lineTo(tile.points[1].x, tile.points[1].y);
                ctx.lineTo(tile.points[2].x, tile.points[2].y);
                ctx.lineTo(tile.points[3].x, tile.points[3].y);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#00ff41';
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        function drawNPCCharacter(pos, color, name) {
            const headPos = pos.add(new Vec3(0, 1.8, 0));
            const bodyPos = pos.add(new Vec3(0, 0.8, 0));
            const legPos = pos.add(new Vec3(0, -0.2, 0));
            
            // Head
            const projHead = project3D(headPos);
            if (projHead && projHead.depth > 0) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(projHead.x, projHead.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(projHead.x - 4, projHead.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(projHead.x + 4, projHead.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Body
            const projBody = project3D(bodyPos);
            if (projBody && projBody.depth > 0) {
                ctx.fillStyle = color;
                ctx.fillRect(projBody.x - 6, projBody.y - 12, 12, 20);
            }
            
            // Legs
            const projLeg = project3D(legPos);
            if (projLeg && projLeg.depth > 0) {
                ctx.fillStyle = color;
                ctx.fillRect(projLeg.x - 3, projLeg.y, 3, 8);
                ctx.fillRect(projLeg.x, projLeg.y, 3, 8);
            }
            
            // Name tag
            if (projHead && projHead.depth > 0) {
                ctx.fillStyle = color;
                ctx.font = '11px monospace';
                ctx.fillText(name, projHead.x - 20, projHead.y - 25);
            }
        }

        function drawBuilding(building) {
            const half_w = building.width / 2;
            const half_d = building.depth / 2;
            const h = building.height;
            
            const corners = [
                building.pos.add(new Vec3(-half_w, 0, -half_d)),
                building.pos.add(new Vec3(half_w, 0, -half_d)),
                building.pos.add(new Vec3(half_w, 0, half_d)),
                building.pos.add(new Vec3(-half_w, 0, half_d)),
                building.pos.add(new Vec3(-half_w, h, -half_d)),
                building.pos.add(new Vec3(half_w, h, -half_d)),
                building.pos.add(new Vec3(half_w, h, half_d)),
                building.pos.add(new Vec3(-half_w, h, half_d))
            ];
            
            const proj = corners.map(c => {
                const p = project3D(c);
                return p || { x: -1000, y: -1000, depth: 99999 };
            });
            
            ctx.strokeStyle = building.color;
            ctx.fillStyle = building.color;
            ctx.globalAlpha = 0.6;
            ctx.lineWidth = 2;
            
            // Draw building faces
            const faces = [
                [0, 1, 5, 4],
                [1, 2, 6, 5],
                [2, 3, 7, 6],
                [3, 0, 4, 7]
            ];
            
            faces.forEach(face => {
                const [a, b, c, d] = face;
                ctx.beginPath();
                ctx.moveTo(proj[a].x, proj[a].y);
                ctx.lineTo(proj[b].x, proj[b].y);
                ctx.lineTo(proj[c].x, proj[c].y);
                ctx.lineTo(proj[d].x, proj[d].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
            
            ctx.globalAlpha = 1;
        }

        function drawNPCs() {
            npcs.forEach(npc => {
                npc.distToPlayer = camera.pos.dist(npc.pos);
                drawNPCCharacter(npc.pos, npc.color, npc.name);
                
                const isClose = npc.distToPlayer < 15;
                if (isClose) {
                    const proj = project3D(npc.pos);
                    if (proj && proj.depth > 0) {
                        ctx.strokeStyle = '#ff10f0';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, 35, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
            });
        }

        function drawBuildings() {
            const renderDist = 80;
            const visibleBuildings = buildings.filter(b => {
                const dist = camera.pos.dist(b.pos);
                return dist < renderDist;
            });
            
            visibleBuildings.sort((a, b) => {
                const distA = camera.pos.dist(a.pos);
                const distB = camera.pos.dist(b.pos);
                return distA - distB;
            });
            
            visibleBuildings.forEach(building => {
                drawBuilding(building);
            });
        }

        function drawPlayer() {
            const playerSize = 1.5;
            const projHead = project3D(camera.pos.add(new Vec3(0, 1.5, 0)));
            const projBody = project3D(camera.pos.add(new Vec3(0, 0.5, 0)));
            
            if (projHead && projBody) {
                ctx.fillStyle = '#39ff14';
                ctx.beginPath();
                ctx.arc(projHead.x, projHead.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#00ff41';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(projHead.x, projHead.y, 12, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // ============== MINIMAP ==============
        function drawMinimap() {
            const mmWidth = minimapCanvas.width;
            const mmHeight = minimapCanvas.height;
            const scale = 2;
            
            minimapCtx.fillStyle = '#0a0e27';
            minimapCtx.fillRect(0, 0, mmWidth, mmHeight);
            
            minimapCtx.strokeStyle = '#00ff41';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(0, 0, mmWidth, mmHeight);
            
            // Draw NPCs
            minimapCtx.fillStyle = '#ff10f0';
            npcs.forEach(npc => {
                const x = (npc.pos.x / 100) * mmWidth;
                const y = (npc.pos.z / 100) * mmHeight;
                minimapCtx.fillRect(x - 2, y - 2, 4, 4);
            });
            
            // Draw player
            minimapCtx.fillStyle = '#00ff41';
            const px = (camera.pos.x / 100) * mmWidth;
            const py = (camera.pos.z / 100) * mmHeight;
            minimapCtx.fillRect(px - 3, py - 3, 6, 6);
            
            // Draw direction
            const forward = camera.getForward();
            minimapCtx.strokeStyle = '#00ff41';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(px, py);
            minimapCtx.lineTo(px + forward.x * 10, py + forward.z * 10);
            minimapCtx.stroke();
        }

        // ============== INTERACTION ==============
        function checkNPCProximity() {
            npcs.forEach(npc => {
                const dist = camera.pos.dist(npc.pos);
                if (dist < 10 && !gameState.challengeActive && !npc.active) {
                    npc.active = true;
                    showChallenge(npc);
                }
            });
        }

        function showChallenge(npc) {
            const challenge = challenges[Math.floor(Math.random() * challenges.length)];
            gameState.currentChallenge = { ...challenge, npc };
            gameState.selectedOption = null;
            gameState.challengeActive = true;
            
            document.getElementById('challengeTitle').textContent = challenge.title + ' (' + npc.name + ')';
            document.getElementById('challengeText').textContent = challenge.question;
            
            const optionsGroup = document.getElementById('optionsGroup');
            optionsGroup.innerHTML = '';
            challenge.options.forEach((opt, idx) => {
                const label = document.createElement('label');
                label.className = 'option-label';
                label.innerHTML = `<input type="radio" name="option" value="${idx}"><span class="option-text">${String.fromCharCode(65+idx)}) ${opt}</span>`;
                label.addEventListener('change', () => { gameState.selectedOption = idx; });
                optionsGroup.appendChild(label);
            });
            
            document.getElementById('modalBackdrop').classList.add('active');
            gameState.challengeTime = 60;
            gameState.challengeStart = Date.now();
        }

        function submitChallenge() {
            if (gameState.selectedOption === null) {
                showToast('SELECT OPTION', 'failure');
                return;
            }
            
            const isCorrect = gameState.selectedOption === gameState.currentChallenge.correct;
            gameState.totalAttempts++;
            
            if (isCorrect) {
                gameState.correctAnswers++;
                gameState.systemsMet++;
                gameState.score += 50;
                gameState.currentChallenge.npc.active = false;
                showToast('+50 POINTS', 'success');
            } else {
                gameState.score = Math.max(0, gameState.score - 10);
                showToast('-10 POINTS', 'failure');
            }
            
            closeChallenge();
        }

        function closeChallenge() {
            gameState.challengeActive = false;
            document.getElementById('modalBackdrop').classList.remove('active');
        }

        function showToast(msg, type) {
            const toast = document.createElement('div');
            toast.className = 'toast ' + (type === 'failure' ? 'failure' : '');
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function setMoveTarget(screenX, screenY) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const relX = screenX - centerX;
            const relY = screenY - centerY;
            
            const forward = camera.getForward();
            const right = camera.getRight();
            
            const screenDist = Math.sqrt(relX*relX + relY*relY);
            const moveDir = forward.mul(-relY / 200).add(right.mul(relX / 200)).normalize();
            const targetDist = Math.min(30, screenDist / 10);
            
            movement.targetPos = camera.pos.add(moveDir.mul(targetDist));
            movement.targetPos.x = Math.max(0, Math.min(100, movement.targetPos.x));
            movement.targetPos.z = Math.max(0, Math.min(100, movement.targetPos.z));
            movement.isMoving = true;
        }

        // ============== UPDATE ==============
        function updateCamera() {
            const speed = 35; // units per second
            const stopDist = 0.5;
            
            if (movement.isMoving && movement.targetPos) {
                const diff = movement.targetPos.sub(camera.pos);
                const dist = Math.sqrt(diff.x*diff.x + diff.z*diff.z);
                
                if (dist > stopDist) {
                    const dir = diff.normalize();
                    camera.pos = camera.pos.add(dir.mul(speed * 0.016));
                    gameState.playerSpeed = speed * 0.016;
                } else {
                    movement.isMoving = false;
                    gameState.playerSpeed = 0;
                }
            } else {
                gameState.playerSpeed = 0;
            }
            
            // Clamp position
            camera.pos.x = Math.max(0, Math.min(100, camera.pos.x));
            camera.pos.z = Math.max(0, Math.min(100, camera.pos.z));
            camera.pos.y = Math.max(-5, Math.min(20, camera.pos.y));
            
            // Update euler with mouse
            camera.euler.y += mouse.dx;
            camera.euler.x += mouse.dy;
            camera.euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.euler.x));
            mouse.dx = 0;
            mouse.dy = 0;
        }

        function updateHUD() {
            document.getElementById('posDisplay').textContent = 
                camera.pos.x.toFixed(1) + ', ' + 
                camera.pos.y.toFixed(1) + ', ' + 
                camera.pos.z.toFixed(1);
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('systemsDisplay').textContent = gameState.systemsMet + '/8';
            document.getElementById('speedDisplay').textContent = (gameState.playerSpeed * 1000).toFixed(0);
        }

        // ============== RENDER LOOP ==============
        function render() {
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawTerrain();
            drawBuildings();
            drawNPCs();
            drawPlayer();
            
            // Debug info
            ctx.fillStyle = '#00ff41';
            ctx.font = '12px monospace';
            ctx.fillText('FPS: ' + Math.round(1000/16), canvas.width - 120, 30);
        }

        function gameLoop() {
            updateCamera();
            checkNPCProximity();
            updateHUD();
            drawMinimap();
            render();
            
            if (gameState.challengeActive) {
                const elapsed = (Date.now() - gameState.challengeStart) / 1000;
                const timeLeft = Math.max(0, 60 - elapsed);
                const progress = timeLeft / 60;
                document.getElementById('timerFill').style.width = (progress * 100) + '%';
                
                if (timeLeft <= 0) {
                    closeChallenge();
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        document.getElementById('submitBtn').addEventListener('click', submitChallenge);
        document.getElementById('cancelBtn').addEventListener('click', closeChallenge);

        gameLoop();
    </script>
</body>
</html>
