<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isometric Reconnaissance</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0e27;
            font-family: 'Courier New', monospace;
            color: #00ff41;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #0a0e27;
            display: block;
            margin: 0;
            padding: 0;
        }

        canvas {
            display: block;
            cursor: crosshair;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
        }

        /* CRT Scanlines - Static overlay, no animation on mobile */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
        }

        /* Noise overlay */
        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 49;
            background-image: url('data:image/svg+xml,<svg width="256" height="256" xmlns="http://www.w3.org/2000/svg"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" result="noise" /></filter><rect width="100%25" height="100%25" fill="rgba(0,255,65,0.03)" filter="url(%23noise)" /></svg>');
            opacity: 0.4;
        }

        /* Global CRT flicker */
        @keyframes crt-flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.97; }
        }

        @media (prefers-reduced-motion: no-preference) {
            #gameContainer {
                animation: crt-flicker 0.05s infinite;
            }
        }

        /* HUD Styles */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 40;
            font-size: 14px;
            line-height: 1.6;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        .hud-line {
            color: #00ff41;
            margin: 4px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hud-label {
            color: #ff10f0;
        }

        .hud-value {
            color: #00ffff;
        }

        /* Modal Styles */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            z-index: 100;
            pointer-events: all;
        }

        .modal-backdrop.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .challenge-modal {
            background: rgba(10, 14, 39, 0.95);
            border: 3px solid #00ff41;
            border-radius: 4px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.3), inset 0 0 20px rgba(255, 16, 240, 0.1);
            animation: modal-pulse 2s ease-in-out infinite;
        }

        @keyframes modal-pulse {
            0%, 100% {
                box-shadow: 0 0 30px rgba(0, 255, 65, 0.3), inset 0 0 20px rgba(255, 16, 240, 0.1);
            }
            50% {
                box-shadow: 0 0 50px rgba(0, 255, 65, 0.6), inset 0 0 30px rgba(255, 16, 240, 0.2);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .challenge-modal {
                animation: none;
            }
        }

        .challenge-modal h2 {
            color: #00ff41;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: -3px 0 0 #ff10f0, 3px 0 0 #00ffff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .challenge-modal p {
            color: #00ffff;
            font-size: 16px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .timer-bar {
            width: 100%;
            height: 12px;
            background: #0a0e27;
            border: 2px solid #00ff41;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff41, #39ff14);
            width: 100%;
            transition: width 0.05s linear;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.7);
        }

        .options-group {
            margin-bottom: 30px;
        }

        .option-label {
            display: flex;
            align-items: center;
            padding: 12px;
            margin: 10px 0;
            background: rgba(0, 255, 65, 0.05);
            border: 2px solid #00ff41;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-label:hover {
            background: rgba(0, 255, 65, 0.15);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.4);
        }

        .option-label input[type="radio"] {
            margin-right: 12px;
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #00ff41;
        }

        .option-text {
            flex: 1;
            color: #00ffff;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        button {
            padding: 12px 24px;
            background: #0a0e27;
            color: #00ff41;
            border: 2px solid #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: #00ff41;
            color: #0a0e27;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .difficulty-stars {
            display: inline-block;
            color: #ff10f0;
            margin-left: 8px;
        }

        .toast {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 65, 0.95);
            color: #0a0e27;
            padding: 16px 32px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 101;
            animation: toast-pop 0.3s ease-out;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.6);
        }

        .toast.failure {
            background: rgba(255, 0, 0, 0.95);
            color: #fff;
        }

        @keyframes toast-pop {
            0% {
                transform: translateX(-50%) scale(0.5);
                opacity: 0;
            }
            100% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }
        }

        .success-flash {
            animation: success-flash 0.4s ease-out;
        }

        @keyframes success-flash {
            0% {
                background: rgba(0, 255, 65, 0.3);
            }
            100% {
                background: rgba(0, 0, 0, 0);
            }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            #hud {
                font-size: 12px;
                top: 10px;
                left: 10px;
            }

            .challenge-modal {
                padding: 20px;
            }

            .challenge-modal h2 {
                font-size: 18px;
            }

            .challenge-modal p {
                font-size: 14px;
            }

            .option-label {
                padding: 10px;
                margin: 8px 0;
            }

            button {
                padding: 10px 16px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="noise-overlay"></div>
        <div id="hud">
            <div class="hud-line"><span class="hud-label">SCORE:</span> <span class="hud-value" id="scoreDisplay">0</span></div>
            <div class="hud-line"><span class="hud-label">DIFFICULTY:</span> <span class="hud-value" id="difficultyDisplay">1.0x</span></div>
            <div class="hud-line"><span class="hud-label">NPCS:</span> <span class="hud-value" id="npcDisplay">0/6</span></div>
            <div class="hud-line"><span class="hud-label">ACCURACY:</span> <span class="hud-value" id="accuracyDisplay">0%</span></div>
        </div>
    </div>

    <div id="modalBackdrop" class="modal-backdrop">
        <div class="challenge-modal">
            <h2 id="challengeTitle"></h2>
            <p id="challengeText"></p>
            <div class="timer-bar">
                <div class="timer-fill" id="timerFill"></div>
            </div>
            <div class="options-group" id="optionsGroup"></div>
            <div class="button-group">
                <button id="submitBtn">SUBMIT ANSWER</button>
                <button id="cancelBtn">CANCEL</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== Three.js Setup ====================
        const canvas = document.getElementById('gameCanvas');
        
        if (!canvas) {
            console.error('Canvas element not found!');
        }
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e27);
        
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        camera.position.set(25, 35, 25);
        camera.lookAt(10, 0, 8);
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: true, 
            alpha: false,
            preserveDrawingBuffer: false
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowShadowMap;
        renderer.setClearColor(0x0a0e27, 1.0);
        
        console.log('Three.js scene initialized');
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        console.log('Ambient light added');
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(30, 40, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        directionalLight.shadow.camera.far = 200;
        scene.add(directionalLight);
        console.log('Directional light added');
        
        const pointLight = new THREE.PointLight(0xff10f0, 0.6, 100);
        pointLight.position.set(10, 15, 10);
        scene.add(pointLight);
        console.log('Point light added');

        // ==================== Game Constants ====================
        const MODAL_BACKDROP = document.getElementById('modalBackdrop');
        const TILE_SIZE = 2;
        const TILEMAP_WIDTH = 20;
        const TILEMAP_HEIGHT = 16;
        const PLAYER_SPEED = 8; // units per second
        const CHALLENGE_TIME_BASE = 60; // seconds
        const DIFFICULTY_INCREMENT = 0.2;

        const COLOR_MAP = {
            crtGreen: 0x00ff41,
            crtGreenDark: 0x00cc33,
            magenta: 0xff10f0,
            cyan: 0x00ffff,
            black: 0x0a0e27,
            neonLime: 0x39ff14,
            acidGreen: 0x10ff10,
            water: 0x0088ff,
            stone: 0x666666
        };

        // ==================== Game State ====================
        const gameState = {
            playerPos: { x: 10, y: 8, z: 0 },
            targetPos: null,
            pathQueue: [],
            score: 0,
            difficulty: 1.0,
            npcsMet: 0,
            totalAttempts: 0,
            correctAnswers: 0,
            currentChallenge: null,
            selectedOption: null,
            challengeActive: false,
            lastNoiseUpdate: 0
        };

        let tilemap = [];
        let npcMap = {};
        let playerMesh = null;
        let npcMeshes = [];
        let tileGroup = new THREE.Group();
        scene.add(tileGroup);

        // ==================== Tilemap Generation ====================
        function initTilemap() {
            tilemap = new Uint8Array(TILEMAP_WIDTH * TILEMAP_HEIGHT);
            
            for (let i = 0; i < tilemap.length; i++) {
                tilemap[i] = 0;
            }

            for (let i = 0; i < 30; i++) {
                const x = Math.floor(Math.random() * TILEMAP_WIDTH);
                const y = Math.floor(Math.random() * TILEMAP_HEIGHT);
                if (Math.abs(x - gameState.playerPos.x) > 3 && Math.abs(y - gameState.playerPos.y) > 3) {
                    tilemap[y * TILEMAP_WIDTH + x] = Math.random() > 0.5 ? 1 : 2;
                }
            }
        }

        function isWalkable(x, y) {
            if (x < 0 || x >= TILEMAP_WIDTH || y < 0 || y >= TILEMAP_HEIGHT) return false;
            const tileType = tilemap[y * TILEMAP_WIDTH + x];
            return tileType === 0;
        }

        // ==================== Tile Rendering ====================
        function createTileMesh(gridX, gridY, tileType) {
            const x = gridX * TILE_SIZE;
            const y = gridY * TILE_SIZE;
            
            const geometry = new THREE.BoxGeometry(TILE_SIZE * 0.9, 0.3, TILE_SIZE * 0.9);
            let color = COLOR_MAP.crtGreen;
            let emissive = 0x003300;
            if (tileType === 1) {
                color = COLOR_MAP.water;
                emissive = 0x002266;
            }
            if (tileType === 2) {
                color = COLOR_MAP.stone;
                emissive = 0x333333;
            }
            
            const material = new THREE.MeshStandardMaterial({ 
                color, 
                emissive,
                roughness: 0.7,
                metalness: 0.1
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0, y);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { gridX, gridY, tileType };
            
            return mesh;
        }

        function renderTilemap() {
            tileGroup.clear();
            
            for (let y = 0; y < TILEMAP_HEIGHT; y++) {
                for (let x = 0; x < TILEMAP_WIDTH; x++) {
                    const tileType = tilemap[y * TILEMAP_WIDTH + x];
                    const mesh = createTileMesh(x, y, tileType);
                    tileGroup.add(mesh);
                }
            }
        }

        // ==================== Player Creation ====================
        function createPlayer() {
            const group = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: COLOR_MAP.neonLime,
                emissive: COLOR_MAP.neonLime,
                emissiveIntensity: 0.3,
                roughness: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: COLOR_MAP.crtGreen,
                emissive: COLOR_MAP.crtGreen,
                emissiveIntensity: 0.4,
                roughness: 0.4
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.65;
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            
            // Glow effect with point light
            const headLight = new THREE.PointLight(COLOR_MAP.cyan, 0.8, 5);
            headLight.position.copy(head.position);
            group.add(headLight);
            
            group.position.set(gameState.playerPos.x * TILE_SIZE, 0.5, gameState.playerPos.y * TILE_SIZE);
            group.castShadow = true;
            return group;
        }

        // ==================== NPC Definitions ====================
        const npcs = [
            {
                id: 'npc1',
                pos: { x: 2, y: 2 },
                name: 'Network Monitor',
                title: 'PACKET ANALYSIS',
                question: 'Which protocol commonly uses port 443 for secure communication?',
                options: ['HTTPS', 'FTP', 'Telnet', 'SMTP'],
                correct: 0
            },
            {
                id: 'npc2',
                pos: { x: 17, y: 3 },
                name: 'Traffic Decoder',
                title: 'DECODE THE SIGNAL',
                question: 'What is "48656C6C6F" in hexadecimal converted to ASCII?',
                options: ['Hello', 'Help', 'Hallo', 'Helix'],
                correct: 0
            },
            {
                id: 'npc3',
                pos: { x: 10, y: 14 },
                name: 'Log Analyst',
                title: 'ERROR FORENSICS',
                question: 'An HTTP 401 error typically indicates what condition?',
                options: ['Unauthorized access', 'Not Found', 'Server Error', 'Bad Gateway'],
                correct: 0
            },
            {
                id: 'npc4',
                pos: { x: 3, y: 12 },
                name: 'Vulnerability Scout',
                title: 'SECURITY AUDIT',
                question: 'Which authentication mechanism sends credentials in plaintext?',
                options: ['Basic Auth', 'OAuth 2.0', 'JWT', 'Kerberos'],
                correct: 0
            },
            {
                id: 'npc5',
                pos: { x: 16, y: 10 },
                name: 'Firewall Inspector',
                title: 'GATEWAY ANALYSIS',
                question: 'A SYN flood attack targets which layer of the OSI model?',
                options: ['Transport Layer', 'Application Layer', 'Data Link Layer', 'Physical Layer'],
                correct: 0
            },
            {
                id: 'npc6',
                pos: { x: 8, y: 2 },
                name: 'Encryption Expert',
                title: 'CIPHER MASTERY',
                question: 'What is the primary purpose of a salt in password hashing?',
                options: ['Prevent rainbow table attacks', 'Speed up hashing', 'Encrypt data', 'Verify authenticity'],
                correct: 0
            }
        ];

        function initNPCs() {
            npcMap = {};
            npcMeshes = [];
            
            npcs.forEach(npc => {
                const key = `${npc.pos.x},${npc.pos.y}`;
                npcMap[key] = npc;
                npc.met = false;
                
                // Create NPC mesh
                const group = new THREE.Group();
                
                // NPC body as a cube
                const bodyGeometry = new THREE.BoxGeometry(0.4, 0.8, 0.4);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: COLOR_MAP.cyan,
                    emissive: COLOR_MAP.cyan,
                    emissiveIntensity: 0.2,
                    roughness: 0.6
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // NPC head
                const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: COLOR_MAP.magenta,
                    emissive: COLOR_MAP.magenta,
                    emissiveIntensity: 0.3,
                    roughness: 0.5
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 0.6;
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);
                
                group.position.set(npc.pos.x * TILE_SIZE, 0.5, npc.pos.y * TILE_SIZE);
                group.userData = { npcId: npc.id, npcKey: key };
                group.castShadow = true;
                
                scene.add(group);
                npcMeshes.push(group);
            });
        }

        // ==================== A* Pathfinding ====================
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function findPath(start, goal) {
            const openSet = [start];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const key = (pos) => `${pos.x},${pos.y}`;

            gScore.set(key(start), 0);
            fScore.set(key(start), heuristic(start, goal));

            while (openSet.length > 0) {
                let current = openSet[0];
                let currentIdx = 0;
                for (let i = 1; i < openSet.length; i++) {
                    if (fScore.get(key(openSet[i])) < fScore.get(key(current))) {
                        current = openSet[i];
                        currentIdx = i;
                    }
                }

                if (current.x === goal.x && current.y === goal.y) {
                    const path = [current];
                    let curr = current;
                    while (cameFrom.has(key(curr))) {
                        curr = cameFrom.get(key(curr));
                        path.unshift(curr);
                    }
                    return path;
                }

                openSet.splice(currentIdx, 1);

                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];

                for (const neighbor of neighbors) {
                    if (!isWalkable(neighbor.x, neighbor.y)) continue;

                    const tentativeGScore = gScore.get(key(current)) + 1;

                    if (!gScore.has(key(neighbor)) || tentativeGScore < gScore.get(key(neighbor))) {
                        cameFrom.set(key(neighbor), current);
                        gScore.set(key(neighbor), tentativeGScore);
                        fScore.set(key(neighbor), tentativeGScore + heuristic(neighbor, goal));

                        if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }

            return [];
        }

        // ==================== Challenge System ====================
        const challengePool = [
            {
                title: 'AUTHENTICATE',
                question: 'Which factor is NOT part of multi-factor authentication?',
                options: ['Something you know', 'Something you remember', 'Something you have', 'Something you are'],
                correct: 1
            },
            {
                title: 'NETWORK SCAN',
                question: 'What does NMAP commonly stand for?',
                options: ['Network Mapper', 'Network Monitor', 'Net Map', 'Network Manager'],
                correct: 0
            },
            {
                title: 'VULNERABILITY',
                question: 'A cross-site scripting (XSS) attack exploits which component?',
                options: ['Client-side input validation', 'Server-side firewall', 'Network latency', 'Database encryption'],
                correct: 0
            },
            {
                title: 'FORENSICS',
                question: 'What is the primary purpose of a honeypot?',
                options: ['Attract and detect attackers', 'Encrypt data', 'Speed up networks', 'Validate certificates'],
                correct: 0
            },
            {
                title: 'CIPHER TEXT',
                question: 'Which encryption standard is considered deprecated for modern use?',
                options: ['DES', 'AES-256', 'ChaCha20', 'AES-128'],
                correct: 0
            },
            {
                title: 'INTRUSION',
                question: 'An IDS differs from an IPS in that it:',
                options: ['Only detects threats without blocking', 'Only blocks threats without detecting', 'Requires manual intervention', 'Works offline'],
                correct: 0
            },
            {
                title: 'MALWARE',
                question: 'Which term describes malware that replicates itself?',
                options: ['Virus', 'Trojan', 'Rootkit', 'Ransomware'],
                correct: 0
            },
            {
                title: 'DATA BREACH',
                question: 'What is the most common cause of data breaches?',
                options: ['Phishing attacks', 'Natural disasters', 'Hardware failure', 'Cosmic radiation'],
                correct: 0
            }
        ];

        function getRandomChallenge() {
            return challengePool[Math.floor(Math.random() * challengePool.length)];
        }

        function showChallenge(npc) {
            const challenge = getRandomChallenge();
            const timeLimit = Math.max(30, Math.floor(CHALLENGE_TIME_BASE / gameState.difficulty));

            gameState.currentChallenge = {
                npc,
                ...challenge,
                timeRemaining: timeLimit,
                timeLimit,
                startTime: Date.now()
            };

            gameState.selectedOption = null;
            gameState.challengeActive = true;

            // Render modal
            document.getElementById('challengeTitle').textContent = challenge.title;
            document.getElementById('challengeText').textContent = challenge.question;

            const optionsGroup = document.getElementById('optionsGroup');
            optionsGroup.innerHTML = '';
            const labels = ['A)', 'B)', 'C)', 'D)'];
            challenge.options.forEach((option, idx) => {
                const label = document.createElement('label');
                label.className = 'option-label';
                label.innerHTML = `
                    <input type="radio" name="option" value="${idx}">
                    <span class="option-text">${labels[idx]} ${option}</span>
                `;
                label.addEventListener('change', () => {
                    gameState.selectedOption = idx;
                });
                optionsGroup.appendChild(label);
            });

            MODAL_BACKDROP.classList.add('active');
            updateTimer();
            challengeTimerInterval = setInterval(updateTimer, 50);
        }

        let challengeTimerInterval = null;

        function updateTimer() {
            if (!gameState.currentChallenge) return;

            const elapsed = (Date.now() - gameState.currentChallenge.startTime) / 1000;
            gameState.currentChallenge.timeRemaining = Math.max(0, gameState.currentChallenge.timeLimit - elapsed);

            const progress = gameState.currentChallenge.timeRemaining / gameState.currentChallenge.timeLimit;
            const timerFill = document.getElementById('timerFill');
            timerFill.style.width = (progress * 100) + '%';

            // Color change as time runs out
            if (progress > 0.66) {
                timerFill.style.background = 'linear-gradient(90deg, #00ff41, #39ff14)';
            } else if (progress > 0.33) {
                timerFill.style.background = 'linear-gradient(90deg, #ffaa00, #ff6600)';
            } else {
                timerFill.style.background = 'linear-gradient(90deg, #ff0000, #cc0000)';
            }

            if (gameState.currentChallenge.timeRemaining <= 0) {
                closeChallenge(false, true); // timeout
            }
        }

        function submitChallenge() {
            if (gameState.selectedOption === null) return;

            clearInterval(challengeTimerInterval);

            const isCorrect = gameState.selectedOption === gameState.currentChallenge.correct;
            gameState.totalAttempts++;

            if (isCorrect) {
                gameState.correctAnswers++;
                gameState.npcsMet++;
                const points = Math.floor(10 * gameState.difficulty);
                gameState.score += points;
                showToast(`+${points} POINTS`, 'success');

                setTimeout(() => {
                    closeChallenge(true);
                }, 300);
            } else {
                gameState.score = Math.max(0, gameState.score - 5);
                showToast('INCORRECT - 5 POINTS', 'failure');
                
                setTimeout(() => {
                    closeChallenge(false);
                }, 300);
            }

            updateHUD();
        }

        function closeChallenge(success, timeout = false) {
            gameState.challengeActive = false;
            MODAL_BACKDROP.classList.remove('active');

            if (success) {
                gameState.difficulty += DIFFICULTY_INCREMENT;
                gameState.currentChallenge.npc.met = true;

                if (gameState.npcsMet >= 6) {
                    setTimeout(() => {
                        showToast('LEGENDARY MODE UNLOCKED!', 'success');
                    }, 500);
                }
            } else if (!timeout) {
                // Player can try again
            }

            gameState.currentChallenge = null;
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type === 'success' ? '' : 'failure'}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 2000);
        }

        // ==================== Input Handling (Raycasting) ====================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onCanvasClick(event) {
            if (gameState.challengeActive) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(tileGroup.children, true);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const userData = hit.object.parent.userData || hit.object.userData;
                const gridX = userData.gridX;
                const gridY = userData.gridY;

                // Check if NPC at this location
                const npcKey = `${gridX},${gridY}`;
                if (npcMap[npcKey] && !npcMap[npcKey].met) {
                    showChallenge(npcMap[npcKey]);
                    return;
                }

                // Pathfind
                if (isWalkable(gridX, gridY)) {
                    const start = { x: gameState.playerPos.x, y: gameState.playerPos.y };
                    const goal = { x: gridX, y: gridY };
                    const path = findPath(start, goal);
                    gameState.pathQueue = path.slice(1);
                }
            }
        }

        function onTouchClick(event) {
            if (gameState.challengeActive) return;

            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(tileGroup.children, true);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const userData = hit.object.parent.userData || hit.object.userData;
                const gridX = userData.gridX;
                const gridY = userData.gridY;

                const npcKey = `${gridX},${gridY}`;
                if (npcMap[npcKey] && !npcMap[npcKey].met) {
                    showChallenge(npcMap[npcKey]);
                    return;
                }

                if (isWalkable(gridX, gridY)) {
                    const start = { x: gameState.playerPos.x, y: gameState.playerPos.y };
                    const goal = { x: gridX, y: gridY };
                    const path = findPath(start, goal);
                    gameState.pathQueue = path.slice(1);
                }
            }
        }

        // ==================== Movement ====================
        function updatePlayer(deltaTime) {
            if (gameState.pathQueue.length === 0) return;

            const nextPos = gameState.pathQueue[0];
            const targetWorldX = nextPos.x * TILE_SIZE;
            const targetWorldY = nextPos.y * TILE_SIZE;

            const dx = targetWorldX - playerMesh.position.x;
            const dy = targetWorldY - playerMesh.position.z;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const moveAmount = PLAYER_SPEED * deltaTime;

            if (distance <= moveAmount) {
                gameState.playerPos.x = nextPos.x;
                gameState.playerPos.y = nextPos.y;
                playerMesh.position.x = targetWorldX;
                playerMesh.position.z = targetWorldY;
                gameState.pathQueue.shift();
            } else {
                playerMesh.position.x += (dx / distance) * moveAmount;
                playerMesh.position.z += (dy / distance) * moveAmount;
            }
        }

        // ==================== HUD & UI ====================
        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('difficultyDisplay').textContent = gameState.difficulty.toFixed(1) + 'x';
            document.getElementById('npcDisplay').textContent = gameState.npcsMet + '/6';
            const accuracy = gameState.totalAttempts > 0 
                ? Math.round((gameState.correctAnswers / gameState.totalAttempts) * 100)
                : 0;
            document.getElementById('accuracyDisplay').textContent = accuracy + '%';
        }

        // ==================== Event Listeners ====================
        canvas.addEventListener('click', onCanvasClick);
        canvas.addEventListener('touchstart', onTouchClick);

        document.getElementById('submitBtn').addEventListener('click', () => {
            if (!gameState.challengeActive) return;
            submitChallenge();
        });

        document.getElementById('cancelBtn').addEventListener('click', () => {
            if (!gameState.challengeActive) return;
            clearInterval(challengeTimerInterval);
            closeChallenge(false);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== Game Loop & Initialization ====================
        let clock = new THREE.Clock();

        function gameLoop() {
            const deltaTime = clock.getDelta();
            
            updatePlayer(deltaTime);
            updateHUD();

            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        function init() {
            console.log('Initializing game...');
            initTilemap();
            console.log('Tilemap initialized, adding to scene');
            renderTilemap();
            console.log('Tilemap rendered, tiles added:', tileGroup.children.length);
            initNPCs();
            console.log('NPCs initialized:', npcMeshes.length);
            playerMesh = createPlayer();
            console.log('Player created');
            scene.add(playerMesh);
            console.log('Player added to scene');
            console.log('Scene children count:', scene.children.length);
            updateHUD();
            console.log('Starting game loop');
            gameLoop();
        }

        // Start the game
        console.log('Page loaded, starting init...');
        init();
    </script>
</body>
</html>
